// Generated by CoffeeScript 2.3.2
(function() {
  // Validation methods for settings
  var Achievements, Q, Settings, StorageItem, validate_bool, validate_noop, validate_num, validate_num_lims,
    indexOf = [].indexOf;

  validate_bool = function(val) {
    var num;
    if (typeof val === "string") {
      val = val.toLowerCase();
      if (val === false.toString()) {
        return false;
      } else if (val === true.toString()) {
        return true;
      } else {
        num = Number(val);
        if (num === 0) {
          return false;
        } else if (num === 1) {
          return true;
        } else {
          return console.log('Cannot parse string "' + val + '"as boolean');
        }
      }
    } else {
      //throw 'Cannot parse string "' + val + '"as boolean'
      return Boolean(val);
    }
  };

  validate_num_lims = function(val, minVal = null, maxVal = null) {
    var num;
    num = Number(val);
    if (isNaN(num)) {
      return console.log('Cannot parse "' + val + '"as number');
    } else {
      //throw 'Cannot parse "' + val + '"as number'
      if (minVal != null) {
        num = Math.max(minVal, num);
      }
      if (maxVal != null) {
        num = Math.min(maxVal, num);
      }
      return num;
    }
  };

  validate_num = function(val) {
    return validate_num_lims(val, null, null);
  };

  validate_noop = function(val) {
    return val;
  };

  StorageItem = class StorageItem {
    // Something store-able in local storage, with a default
    constructor(key, default_val, validator) {
      this.key = this.getKey(key);
      this.default_val = default_val;
      this.staged_val = void 0; // stage changes if not able to commit (need user permission)
      this.is_boolean = typeof default_val === "boolean";
      this.validator = validator;
    }

    getKey(key) {
      return "zombieGame:" + key;
    }

    get() {
      if (this.is_boolean) {
        return this.boolValueOrDefault(this.key, this.default_val);
      } else {
        return this.staged_val || localStorage.getItem(this.key) || this.default_val;
      }
    }

    isSaved() {
      return !(localStorage.getItem(this.key) === null);
    }

    setDefault(default_val) {
      var default_val_v;
      default_val_v = this.validator(default_val);
      if (default_val_v != null) {
        // Set a new default - this *won't* override a user-saved setting
        return this.default_val = default_val_v;
      } else {
        return console.log(`Error setting default val: ${default_val}`);
      }
    }

    set(s, force_save = false) {
      var s_v;
      s_v = this.validator(s);
      if ((s_v != null) && (force_save || this.get() !== s_v)) {
        return localStorage.setItem(this.key, s_v);
      }
    }

    set_staged(s) {
      var s_v;
      s_v = this.validator(s);
      if (s_v != null) {
        return this.staged_val = s_v;
      }
    }

    reset() {
      return localStorage.removeItem(this.key);
    }

    commit_staged_change() {
      if (this.staged_val != null) {
        this.set(this.staged_val, true);
        return this.staged_val = void 0;
      }
    }

    boolValueOrDefault(key, defaultVal) {
      var stringVal;
      stringVal = localStorage.getItem(key);
      if (stringVal === null) {
        return defaultVal;
      } else {
        if (stringVal === false.toString()) {
          return false;
        } else if (stringVal === true.toString()) {
          return true;
        } else {
          console.error(`Cannot read bool value for key ${key}`);
          return defaultVal;
        }
      }
    }

  };

  Achievements = class Achievements {
    // Progress in game, saved in local storage
    // Also encapsulates any composite achievements, like getting full marks.
    constructor(total_levels) {
      var j, level, ref;
      this.availableLevel = new StorageItem("availableLevel", 1, validate_num);
      this.total_levels = total_levels;
      // progress is stored individually per-level
      this.progressKey = "levelProgress";
      this.progress = [];
      for (level = j = 0, ref = total_levels; (0 <= ref ? j <= ref : j >= ref); level = 0 <= ref ? ++j : --j) {
        this.progress.push(new StorageItem(this.progressKey + ":" + level, 0, validate_num));
      }
      // record when we've congratulated the user
      this.congratulatedMainLevels = new StorageItem("congratulatedMainLevels", false, validate_bool);
      this.congratulatedMainLevelsFullStars = new StorageItem("congratulatedMainLevelsFullStars", false, validate_bool);
      this.congratulatedAllLevels = new StorageItem("congratulatedAllLevels", false, validate_bool);
      this.congratulatedAllLevelsFullStars = new StorageItem("congratulatedAllLevelsFullStars", false, validate_bool);
    }

    getNextUncompletedLevel() {
      var j, level, prog, ref;
      for (level = j = 0, ref = this.total_levels; (0 <= ref ? j <= ref : j >= ref); level = 0 <= ref ? ++j : --j) {
        prog = this.progress[level].get();
        if (prog === 0) {
          return level;
        }
      }
      return level; // if all complete, returns (N+1) 
    }

    getProgressForLevel(level) {
      return this.progress[level].get();
    }

    hasCompletedMainLevels() {
      var j, level, prog;
      for (level = j = 1; j <= 5; level = ++j) {
        prog = this.progress[level].get();
        if (prog === 0) {
          return false;
        }
      }
      return true;
    }

    hasCompletedMainLevelsFullStars() {
      var j, level, prog;
      for (level = j = 1; j <= 5; level = ++j) {
        prog = this.progress[level].get();
        if (prog < 3) {
          return false;
        }
      }
      return true;
    }

    hasCompletedAllLevels() {
      var j, level, prog, ref;
      for (level = j = 1, ref = this.total_levels; (1 <= ref ? j <= ref : j >= ref); level = 1 <= ref ? ++j : --j) {
        prog = this.progress[level].get();
        if (prog === 0) {
          return false;
        }
      }
      return true;
    }

    hasCompletedAllLevelsFullStars() {
      var j, level, prog, ref;
      for (level = j = 1, ref = this.total_levels; (1 <= ref ? j <= ref : j >= ref); level = 1 <= ref ? ++j : --j) {
        prog = this.progress[level].get();
        if (prog < 3) {
          return false;
        }
      }
      return true;
    }

    evaluatePerformance(score) {
      var message, stars;
      stars = 0;
      message = "";
      if (score <= 0.5) {
        stars = 1;
        message = "Okay";
      } else if (score > 0.5 && score < 0.9) {
        stars = 2;
        message = "Good";
      } else {
        stars = 3;
        message = "Perfect!";
      }
      return {
        "stars": stars,
        "message": message
      };
    }

    update(level, stars) {
      var previousStars;
      // save if better than previous
      previousStars = this.progress[level].get();
      if (stars > previousStars) {
        return this.progress[level].set(stars);
      }
    }

    possiblyStageAchievementsScreen() {
      //# All levels, maximum score
      if (this.hasCompletedAllLevelsFullStars() && !this.congratulatedAllLevelsFullStars.get()) {
        Game.stageAchievementScreen("Amazing!\n\nYou have healed every single zombie in the game.\nTop score!");
        this.congratulatedAllLevelsFullStars.set(true);
        this.congratulatedAllLevelsStars.set(true); // subset of the above
        return true;
      //# All levels complete, any score
      } else if (this.hasCompletedAllLevels() && !this.congratulatedAllLevels.get()) {
        Game.stageAchievementScreen("Hurrah!\n\nYou have completed ALL the levels, including the bonus levels.\n\nWell done!");
        this.congratulatedAllLevelsStars.set(true);
        return true;
      // Main (5) levels, maximum score
      } else if (this.hasCompletedMainLevelsFullStars() && !this.congratulatedMainLevelsFullStars.get()) {
        Game.stageAchievementScreen("Brilliant!\n\nYou have achieved a perfect score on all the main levels. Well done!\n\nIf you've enjoyed it, keep playing to \nrack up more points in the bonus levels.");
        this.congratulatedMainLevelsFullStars.set(true);
        this.congratulatedMainLevels.set(true); // subset of above
        return true;
      // Main (5) levels complete, any score
      } else if (this.hasCompletedMainLevels() && !this.congratulatedMainLevels.get()) {
        Game.stageAchievementScreen("Hooray!\n\nYou have completed all the main levels. Well done!\n\nIf you've enjoyed it, check out the bonus levels, \nor play again to try to heal every single zombie");
        this.congratulatedMainLevels.set(true);
        return true;
      } else {
        return false;
      }
    }

  };

  Settings = class Settings {
    constructor() {
      this.cookiesAccepted = new StorageItem("cookiesAccepted", false, validate_bool);
      this.showCursor = new StorageItem("showCursor", true, validate_bool);
      this.dwellTime = new StorageItem("dwellTime", 1000, function(val) {
        var minVal;
        return validate_num_lims(val, minVal = 0.1);
      });
      this.narrationEnabled = new StorageItem("narrationEnabled", false, validate_bool);
      this.useBuiltinDwell = new StorageItem("useBuiltinDwell", true, validate_bool);
      this.useKeyboardInstead = new StorageItem("useKeyboardInstead", false, validate_bool);
      this.useOwnClickInstead = new StorageItem("useOwnClickInstead", false, validate_bool);
      this.uiScale = new StorageItem("uiScale", 1.0, function(val) {
        var maxVal, minVal;
        return validate_num_lims(val, minVal = 0.05, maxVal = 2.5);
      });
      this.uiOpacity = new StorageItem("uiOpacity", 0.25, function(val) {
        var maxVal, minVal;
        return validate_num_lims(val, minVal = 0.05, maxVal = 1.0);
      });
      this.musicEnabled = new StorageItem("enableMusic", true, validate_bool);
      this.soundFxEnabled = new StorageItem("enableSoundFx", true, validate_bool);
      this.lives = new StorageItem("lives", 3, function(val) {
        var minVal;
        return validate_num_lims(val, minVal = 0);
      });
      this.zombieSpeed = new StorageItem("zombieSpeed", 1.0, function(val) {
        var maxVal, minVal;
        return validate_num_lims(val, minVal = 0.05, maxVal = 2.0);
      });
      this.zombiesChase = new StorageItem("zombiesChase", true, validate_bool);
      this.unlimitedAmmo = new StorageItem("unlimitedAmmo", false, validate_bool);
      this.startWithGun = new StorageItem("startWithGun", false, validate_bool);
      this.narrationVoice = new StorageItem("narrationVoice", "UK English Male", validate_noop);
      
      // will be randomly picked first time, saved after cookie acceptance
      this.femaleDoctor = new StorageItem("femaleDoctor", Boolean(Math.floor(Math.random() * 2)), validate_bool);
    }

  };

  
  // Global styles
  window.Styles = {
    fontsize0: 12,
    // the rest are major third scale, rounded (we don't use all of them)
    fontsize1: 22,
    fontsize2: 25,
    fontsize3: 28,
    fontsize4: 31,
    fontsize5: 35,
    fontsize6: 40,
    fontsize7: 45,
    fontsize8: 50,
    fontsize9: 56,
    fontsize10: 64,
    fontsize11: 71,
    fontsize12: 80,
    fontsize13: 90,
    fontsize14: 100
  };

  // main game object
  window.Game = {
    init: function() {
      var Q, updateVoice;
      // engine instance
      this.Q = Q = Quintus({
        development: true,
        audioSupported: ['ogg', 'mp3']
      });
      // Q.debug = true
      // Q.debugFill = true
      Game.settings = new Settings();
      Game.achievements = new Achievements();
      // Quintus setup
      Q.include("Sprites, Scenes, Input, Touch, Gaze, UI, 2D, Anim, Audio");
      Q.setup({
        // width: 640
        // height: 320
        width: 800, //// Set the default width to 800 pixels
        height: 600, //// Set the default height to 600 pixels
        scaleToFit: true, //// Scale the game to fit the screen of the player's device
        maximize: true,
        upsampleWidth: 640,
        upsampleHeight: 320
      });
      // downsampleWidth: 1024, # Halve the pixel density if resolution
      // downsampleHeight: 768  # is larger than or equal to 1024x768
      Q.controls().touch(Q.SPRITE_UI, [0, 1, 2, 10]);
      Q.enableSound();
      // Extra keybindings not in quintus defaults
      Q.input.bindKey(67, "cursor");
      
      // used for collision detection
      this.SPRITE_NONE = 0;
      this.SPRITE_PLAYER = 1;
      this.SPRITE_TILES = 2;
      this.SPRITE_ENEMY = 4;
      this.SPRITE_BULLET = 8;
      this.SPRITE_PLAYER_COLLECTIBLE = 16;
      this.SPRITE_HUMAN = 32;
      this.SPRITE_ZOMBIE_PLAYER = 64;
      this.SPRITE_ALL = 0xFFFF;
      // rest of init
      this.prepareAssets();
      this.initStats();
      this.initUnloadEvent();
      this.Q.state.set("currentLevel", 0);
      // helpers
      Q.tilePos = function(col, row, otherParams = {}) {
        var position;
        position = {
          x: col * Game.assets.map.tileSize + Game.assets.map.tileSize / 2,
          y: row * Game.assets.map.tileSize + Game.assets.map.tileSize / 2
        };
        return Q._extend(position, otherParams);
      };
      // Set up some things from settings
      if (Game.settings.useOwnClickInstead.get()) {
        this.setupGaze(0);
      } else {
        this.setupGaze(Game.settings.dwellTime.get());
      }
      this.setCursorState(Game.settings.showCursor.get(), false); // don't save since we might not have cookie acceptance yet
      Q.input.on("cursor", this, "toggleCursor");
      
      // Narration setup: 
      if (typeof responsiveVoice === "undefined" || responsiveVoice === null) {
        // Either hasn't loaded yet, or it failed to load (e.g. network issues)
        // Replace with no-op object to avoid errors elsewhere
        window.responsiveVoice = {
          setDefaultVoice: function(x) {
            return console.log("Responsive voice currently unavailable");
          },
          speak: function(x) {
            return console.log("Responsive voice currently unavailable");
          },
          voiceSupport: function() {
            return false;
          }
        };
      }
      
      // Responsive voice never loads immediately, so set it up after a delay
      updateVoice = function() {
        return responsiveVoice.setDefaultVoice(Game.settings.narrationVoice.get());
      };
      setTimeout(updateVoice, 1000);
      
      // Turn on muting when tab not active   
      document.addEventListener('visibilitychange', this.onVisibilityChange, false);
      setInterval(this.onCursorTick, 20);
      // Game mode presets
      Game.presets = [
        {
          name: "Relaxed",
          lives: 100,
          zombieSpeed: 0.5,
          zombiesChase: false,
          unlimitedAmmo: true,
          startWithGun: true
        },
        {
          name: "Default",
          lives: 3,
          zombieSpeed: 1.0,
          zombiesChase: true,
          unlimitedAmmo: false,
          startWithGun: false
        },
        {
          name: "Hardcore",
          lives: 0,
          zombieSpeed: 1.0,
          zombiesChase: true,
          unlimitedAmmo: false,
          startWithGun: false
        }
      ];
      // Any ?var=value params in the url to override settings defaults
      this.processUrlParams();
      
      // Replace url params, so history/bookmarking doesn't include them
      window.history.replaceState(null, null, window.location.pathname);
    },
    
    // processBasicParam: (param, param_name) ->
    processUrlParams: function() {
      var e, force, override, processParam, searchParams;
      try {
        
        // Get URL params, if supported by browser
        searchParams = new URLSearchParams(window.location.search);
        if (searchParams == null) {
          return;
        }
      } catch (error) {
        
        // will get here if URLSearchParams not supported by browser
        console.log("Error parsing search params, loading defaults instead");
        return;
      }
      
      // First look for "force" param, this will determine whether we override saved user settings
      override = false;
      if (searchParams.has("force")) {
        force = searchParams.get("force");
        if (validate_bool(force)) {
          override = true;
        }
      }
      
      // Define generic process function for each parameter
      processParam = function(val, key) {
        var gamemode, gamemode_already_set, p, preset, preset_names, ref;
        console.log(`URL Param ${key}: ${val}`);
        try {
          if (key === "force") {

          // noop, already dealt with
          } else if (key === "gamemode") {
            // special case for gamemode, which preloads several settings        
            gamemode = val;
            preset_names = Game.presets.map((p) => {
              return p.name.toLowerCase();
            });
            if (ref = gamemode.toLowerCase(), indexOf.call(preset_names, ref) >= 0) {
              preset = ((function() {
                var j, len, ref1, results;
                ref1 = Game.presets;
                results = [];
                for (j = 0, len = ref1.length; j < len; j++) {
                  p = ref1[j];
                  if (p.name.toLowerCase() === gamemode) {
                    results.push(p);
                  }
                }
                return results;
              })())[0];
              gamemode_already_set = Game.settings.lives.isSaved() || Game.settings.zombieSpeed.isSaved() || Game.settings.zombiesChase.isSaved() || Game.settings.unlimitedAmmo.isSaved() || Game.settings.startWithGun.isSaved();
              if (gamemode_already_set && !override) {
                return console.log("Some game mode settings already saved, ignoring gamemode=" + val);
              } else {
                Game.settings.lives.set_staged(preset.lives);
                Game.settings.zombieSpeed.set_staged(preset.zombieSpeed);
                Game.settings.zombiesChase.set_staged(preset.zombiesChase);
                Game.settings.unlimitedAmmo.set_staged(preset.unlimitedAmmo);
                return Game.settings.startWithGun.set_staged(preset.startWithGun);
              }
            } else {
              return console.log("Cannot parse game mode: " + value);
            }
          } else {
            
            // stage the change, unless user has already set this
            // we'll commit when we know we have cookie acceptance
            if (Game.settings[key] != null) {
              if (Game.settings[key].isSaved() && !override) {
                return console.log("Setting [" + key + "] is already set to " + Game.settings[key].get() + ". Ignoring URL param (" + value + ")");
              } else {
                return Game.settings[key].set_staged(val);
              }
            } else {
              return console.log("Cannot find setting: " + key);
            }
          }
        } catch (error) {
          return console.log("Cannot parse value in URL for " + key);
        }
      };
      try {
        
        // Process URL params one by one        
        searchParams = new URLSearchParams(window.location.search);
        return searchParams.forEach(processParam);
      } catch (error) {
        e = error;
        // will get here if URLSearchParams not supported by browser
        return console.log("Error parsing search params, loading defaults instead");
      }
    },
    onCookieAcceptance: function() {
      var param, results;
      // Any setup we aren't able to do until we know cookies are accepted
      // If we want to set game settings earlier, we need to cache values in 
      // their 'default' and then commit changes now

      // Save the gender for doctor character
      // (We randomly picked its default upon initialisation)
      if (!Game.settings.femaleDoctor.isSaved()) {
        Game.settings.femaleDoctor.set(Game.settings.femaleDoctor.get(), true);
      }

// Save any params staged, e.g. by URL parsing
      results = [];
      for (param in Game.settings) {
        results.push(Game.settings[param].commit_staged_change());
      }
      return results;
    },
    onCursorTick: function() {
      if (Q.gazeInput) {
        return Q.gazeInput.poke();
      }
    },
    onVisibilityChange: function() {
      console.log(document.visibilityState);
      if (document.visibilityState === "hidden") {
        return Q.AudioManager.mute();
      } else {
        return Q.AudioManager.unmute();
      }
    },
    setupGaze: function(dwell_time) {
      this.Q.controls().untrackGaze();
      return this.Q.controls().trackGaze(this.Q.SPRITE_UI, [0, 1, 2, 10], dwell_time);
    },
    turnOffGaze: function() {
      return this.Q.controls().untrackGaze();
    },
    setCursorState: function(cursor_on, save_state = true) {
      var element;
      console.log("Setting cursor state: " + cursor_on);
      // Update game state
      this.Q.state.set("showCursor", cursor_on);
      
      // Persist in local storage
      if (save_state) {
        Game.settings.showCursor.set(cursor_on);
      }
      // Change styling to hide/show cursor
      element = document.getElementById("quintus_container");
      if (cursor_on) {
        return element.style.cursor = "auto";
      } else {
        return element.style.cursor = "none";
      }
    },
    toggleCursor: function() {
      return this.setCursorState(!Q.state.get("showCursor"));
    },
    // one place of defining assets
    prepareAssets: function() {
      var assetsAsArray, audioAsArray, k, level_assets, levels, v;
      levels = {
        tutorial: {
          dataAsset: "tutorial.tmx",
          bullets: 20
        },
        level1: {
          dataAsset: "level1.tmx",
          bullets: 4
        },
        level2: {
          dataAsset: "level2.tmx",
          bullets: 8
        },
        level3: {
          dataAsset: "level3.tmx",
          bullets: 6
        },
        level4: {
          dataAsset: "level4.tmx",
          bullets: 6
        },
        level5: {
          dataAsset: "level5.tmx",
          bullets: 15
        },
        level6: {
          dataAsset: "steps.tmx",
          bullets: 10,
          name: "Steps"
        },
        level7: {
          dataAsset: "hurdles.tmx",
          bullets: 10,
          name: "Hurdles"
        },
        level8: {
          dataAsset: "pyramid.tmx",
          bullets: 10,
          name: "Pyramid"
        },
        level9: {
          dataAsset: "diamond.tmx",
          bullets: 20,
          name: "Diamond"
        },
        level10: {
          dataAsset: "trickyJumps.tmx",
          bullets: 10,
          name: "Tricky Jumps"
        },
        level11: {
          dataAsset: "tooManyZombies.tmx",
          bullets: 20,
          name: "Too Many Zombies"
        },
        level12: {
          dataAsset: "trickyJumpsMore.tmx",
          bullets: 20,
          name: "More Tricky Jumps"
        },
        level13: {
          dataAsset: "notEnoughBullets.tmx",
          bullets: 2,
          name: "Ammo"
        },
        level14: {
          dataAsset: "something.tmx",
          bullets: 5,
          name: "Untitled"
        },
        level15: {
          dataAsset: "ghostly_platforms.tmx",
          bullets: 5,
          name: "Ghostly Platforms"
        }
      };
      
      // split into array for accessing level details by index
      // and data assets strings for loading 
      this.levels_array = [];
      level_assets = [];
      for (k in levels) {
        v = levels[k];
        this.levels_array.push(v);
        level_assets.push(v.dataAsset);
      }
      // all assets, only file names
      this.assets = {
        characters_f: {
          dataAsset: "characters.json",
          sheet: "characters_f.png"
        },
        characters_m: {
          dataAsset: "characters.json",
          sheet: "characters_m.png"
        },
        controls: {
          dataAsset: "controls.json",
          sheet: "controls.png"
        },
        items: {
          dataAsset: "items.json",
          sheet: "items.png"
        },
        hud_f: {
          dataAsset: "hud.json",
          sheet: "hud_f.png"
        },
        hud_m: {
          dataAsset: "hud.json",
          sheet: "hud_m.png"
        },
        others: {
          dataAsset: "others.json",
          sheet: "others.png"
        },
        misc: {
          dataAsset: "misc.json",
          sheet: "misc.png"
        },
        bullet: {
          dataAsset: "bullet.json",
          sheet: "bullet.png"
        },
        map: {
          sheet: "map_tiles.png"
        },
        gradient: "gradient-top.png",
        tutorial: {
          dataAsset: "tutorial.tmx"
        },
        preview: {
          dataAsset: "preview.tmx"
        }
      };
      Game.achievements = new Achievements(Game.levels_array.length - 1);
      // audio
      this.audio = {
        zombieMode: "zombie_mode.mp3",
        playerBg: "player_bg.mp3",
        zombieNotice: "zombie_notice.mp3",
        gunShot: "gun_shot.mp3",
        collected: "collected.mp3",
        playerHit: "player_hit.mp3",
        humanCreated: "human_created.mp3"
      };
      Game.isMuted = false;
      // convert to array for Q.load    
      assetsAsArray = [];
      this.objValueToArray(this.assets, assetsAsArray);
      // now we can add metadata
      this.assets.map.sheetName = "tiles";
      this.assets.map.tileSize = 70;
      // convert @audio to array
      audioAsArray = [];
      this.objValueToArray(this.audio, audioAsArray);
      // merge assets and audio for Q.load
      return this.assets.all = assetsAsArray.concat(audioAsArray).concat(level_assets);
    },
    // helper to conver obj to array
    objValueToArray: function(obj, array) {
      var key, results, value;
      results = [];
      for (key in obj) {
        value = obj[key];
        if (typeof value === 'string') {
          results.push(array.push(value));
        } else {
          results.push(this.objValueToArray(value, array));
        }
      }
      return results;
    },
    initStats: function() {
      var stats;
      this.Q.stats = stats = new Stats();
      return stats.setMode(0); // 0: fps, 1: ms
    },
    
    // Align top-left
    // stats.domElement.style.position = 'absolute'
    // stats.domElement.style.left = '0px'
    // stats.domElement.style.top = '140px'

    // document.body.appendChild( stats.domElement )
    getUserSettings: function() {
      var setting, settings_to_ignore, user_settings;
      // Get list of settings that user has saved,
      // i.e. not including functional stuff like level progress
      settings_to_ignore = ["cookiesAccepted"];
      user_settings = [];
      for (setting in Game.settings) {
        if (Game.settings[setting].isSaved() && !(indexOf.call(settings_to_ignore, setting) >= 0)) {
          user_settings.push(setting);
        }
      }
      return user_settings;
    },
    resetAllSettings: function() {
      var j, len, results, setting, user_settings;
      user_settings = this.getUserSettings();
      results = [];
      for (j = 0, len = user_settings.length; j < len; j++) {
        setting = user_settings[j];
        console.log('Clearing saved setting for ' + setting);
        results.push(Game.settings[setting].reset());
      }
      return results;
    },
    stageAchievementScreen: function(msg) {
      Q.clearStages();
      return Q.stageScene("achievement_unlocked", {
        "message": msg
      });
    },
    stageLevel: function(number = 1) {
      var Q, level, level_data, num_bullets, start_bullets;
      Q = this.Q;
      start_bullets = Game.settings.startWithGun.get() ? 10 : 0;
      Q.state.set({
        enemiesCounter: 0,
        lives: Number.parseInt(Game.settings.lives.get()),
        bullets: start_bullets,
        hasKey: false,
        hasGun: Game.settings.startWithGun.get(),
        currentLevel: number, // for saving the progress
        canEnterDoor: false
      });
      Game.currentLevelData = { // for level summary
        zombies: {
          healed: 0,
          available: 0
        },
        health: {
          collected: 0,
          available: 0
        },
        bullets: {
          waisted: 0,
          available: 0
        },
        zombieModeFound: false
      };
      // Q.input.touchControls() # render onscreen touch buttons
      Q.clearStages();
      level = Game.levels_array[number];
      // levels are constructed on the fly
      level_data = level.dataAsset;
      num_bullets = level.bullets;
      Q.scene("level", function(stage) {
        return Q.LevelParser.default_load_level(stage, level_data, num_bullets);
      });
      Q.stageScene("level", {
        sort: true
      });
      Q.stageScene("hud", 2, {
        sort: true
      });
      if (!Game.settings.useKeyboardInstead.get()) {
        Q.stageScene("gaze_overlay", 1, {
          sort: true
        });
      }
      // the story
      Game.infoLabel.intro();
      // for analytics
      Game.currentScreen = "level" + number;
      this.Q.state.set("currentLevel", number);
      // unlock the next level
      // We only save progress up to Level 5; bonus levels are always available
      if (number <= 5 && number >= Game.achievements.availableLevel.get()) {
        return Game.achievements.availableLevel.set(number + 1);
      }
    },
    stageLevelSelectScreen: function() {
      var curr_level;
      this.Q.input.disableTouchControls();
      // We'll pick screen according to current level
      curr_level = Q.state.get("currentLevel");
      // reset current level state
      this.Q.state.set("currentLevel", 0);
      this.Q.clearStages();
      if (curr_level <= 5) {
        this.Q.stageScene("levelSelect");
      } else {
        Game.moreLevelsPage = Math.floor((curr_level - 6) / 4);
        this.Q.stageScene("levelSelectMore");
      }
      // for analytics
      return Game.currentScreen = "levelSelect";
    },
    stageEndLevelScreen: function() {
      var new_achievement, performance, score;
      this.Q.input.disableTouchControls();
      this.Q.clearStages();
      // Update score for any new achievements
      score = Game.currentLevelData.zombies.healed / Game.currentLevelData.zombies.available;
      performance = Game.achievements.evaluatePerformance(score);
      Game.achievements.update(Q.state.get("currentLevel"), performance["stars"]);
      new_achievement = Game.achievements.possiblyStageAchievementsScreen();
      if (!new_achievement) {
        this.Q.stageScene("levelSummary", Game.currentLevelData);
      }
      // for analytics
      return Game.currentScreen = "levelSummary for level" + this.Q.state.get("currentLevel");
    },
    stageScreen: function(screen_name) {
      this.Q.clearStages();
      this.Q.stageScene(screen_name);
      // for analytics
      return Game.currentScreen = screen_name;
    },
    stageMoreLevels: function(page) {
      var max_pages, screen_name;
      max_pages = Math.ceil(Game.levels_array.length - 6) / 4;
      if (page >= 0 && page <= max_pages) {
        screen_name = "levelSelectMore";
        Game.moreLevelsPage = page;
        this.Q.clearStages();
        this.Q.stageScene(screen_name);
        // for analytics
        return Game.currentScreen = screen_name;
      }
    },
    stagePreview: function() {
      var Q;
      Q = this.Q;
      Q.state.set({
        enemiesCounter: 0,
        lives: 15,
        bullets: 100,
        hasKey: false,
        hasGun: true,
        currentLevel: 0, // for saving the progress
        canEnterDoor: false
      });
      Game.currentLevelData = { // for level summary
        zombies: {
          healed: 0,
          available: 0
        },
        health: {
          collected: 0,
          available: 0
        },
        bullets: {
          waisted: 0,
          available: 0
        },
        zombieModeFound: false
      };
      Q.clearStages();
      Q.stageScene("preview", {
        sort: true
      });
      if (!Game.settings.useKeyboardInstead.get()) {
        Q.stageScene("gaze_overlay", 1, {
          sort: true
        });
      }
      Q.scene("preview_back_button", function(stage) {
        var marginBottomButtons, menuButton, pauseButton;
        marginBottomButtons = Q.height * 0.1;
        pauseButton = stage.insert(new Q.UI.PauseButton({
          x: marginBottomButtons,
          y: Q.height - marginBottomButtons,
          isSmall: false
        }));
        menuButton = stage.insert(new Q.UI.MenuButton({
          x: Q.width - marginBottomButtons,
          y: Q.height - marginBottomButtons,
          isSmall: false
        }));
        return menuButton.on("click", function(e) {
          return Game.stageScreen("controls_settings");
        });
      });
      return Q.stageScene("preview_back_button", 2, {
        sort: true
      });
    },
    stageTutorial: function() {
      var Q;
      Q = this.Q;
      Q.state.set({
        enemiesCounter: 0,
        lives: 15,
        bullets: 0,
        hasKey: false,
        hasGun: false,
        currentLevel: 0, // for saving the progress
        canEnterDoor: false
      });
      Game.currentLevelData = { // for level summary
        zombies: {
          healed: 0,
          available: 0
        },
        health: {
          collected: 0,
          available: 0
        },
        bullets: {
          waisted: 0,
          available: 0
        },
        zombieModeFound: false
      };
      // Q.input.touchControls() # render onscreen touch buttons
      Q.clearStages();
      Q.stageScene("tutorial", {
        sort: true
      });
      Q.stageScene("hud", 2, {
        sort: true
      });
      // info speaking interferes with (more important) narration of tutorial instrucitons
      if (Game.settings.narrationEnabled.get()) {
        Game.infoLabel.disable();
      }
      if (!Game.settings.useKeyboardInstead.get()) {
        Q.stageScene("gaze_overlay", 1, {
          sort: true
        });
      }
      // the story
      Game.infoLabel.tutorial();
      // for analytics
      Game.currentScreen = "tutorial";
      return this.Q.state.set("currentLevel", 0);
    },
    stageGameOverScreen: function() {
      this.Q.clearStages();
      this.Q.stageScene("gameOver");
      // for analytics
      Game.currentScreen = "gameOver";
      // track events
      return Game.trackEvent("Game Over Screen", "displayed");
    },
    setCameraTo: function(stage, toFollowObj) {
      return stage.follow(toFollowObj, {
        x: true,
        y: true
      }, {
        minX: 0,
        maxX: Game.map.p.w,
        minY: 0,
        maxY: Game.map.p.h
      });
    },
    trackEvent: function(category, action, label, value) {
      if (false) { // we've turned off google analytics for now
        if (label == null) {
          return ga('send', 'event', category, action);
        } else if (value == null) {
          return ga('send', 'event', category, action, label.toString());
        } else {
          // console.log('_gaq.push', category + ' | ', action + ' | ', label.toString())
          return ga('send', 'event', category, action, label.toString(), parseInt(value, 10));
        }
      }
    },
    // console.log('_gaq.push', category + ' | ', action + ' | ', label.toString() + ' | ', parseInt(value, 10))
    initUnloadEvent: function() {
      return window.addEventListener("beforeunload", function(e) {
        return Game.trackEvent("Unload", "Current Screen", Game.currentScreen);
      });
    },
    add_door_button: function(stage, doorPos) {
      var Q;
      Q = this.Q;
      return stage.insert(new Q.UI.DoorButton({
        x: doorPos.x,
        y: doorPos.y - 2.5 * Game.assets.map.tileSize
      }));
    }
  };

  
  // init game
  Game.init();

  Q = Game.Q;

  Q.UI.Container.prototype.subplot = function(nrows, ncols, rowFrom, colFrom, padding_fraction = 0) {
    return this.subplot_multiple(nrows, ncols, rowFrom, colFrom, rowFrom, colFrom, padding_fraction);
  };

  Q.UI.Container.prototype.subplot_multiple = function(nrows, ncols, rowFrom, colFrom, rowTo, colTo, padding_fraction = 0) {
    var cell_h, cell_w, fill, nColsInSubplot, nRowsInSubplot, x, y;
    cell_w = this.p.w / ncols;
    cell_h = this.p.h / nrows;
    if (rowTo === void 0) {
      rowTo = rowFrom;
    }
    if (colTo === void 0) {
      colTo = colFrom;
    }
    nRowsInSubplot = 1 + rowTo - rowFrom;
    nColsInSubplot = 1 + colTo - colFrom;
    x = this.p.x - this.p.w / 2 + (colFrom + nColsInSubplot * 0.5) * cell_w;
    y = this.p.y - this.p.h / 2 + (rowFrom + nRowsInSubplot * 0.5) * cell_h;
    fill = 1.0 - padding_fraction;
    return new Q.UI.Container({
      x: x,
      y: y,
      w: cell_w * nColsInSubplot * fill,
      h: cell_h * nRowsInSubplot * fill
    });
  };

  Q = Game.Q;

  Q.load(Game.assets.all, function() {
    // prepare sheets
    Q.sheet(Game.assets.map.sheetName, Game.assets.map.sheet, {
      tileW: Game.assets.map.tileSize,
      tileH: Game.assets.map.tileSize
    });
    Q.compileSheets(Game.assets.items.sheet, Game.assets.items.dataAsset);
    Q.compileSheets(Game.assets.misc.sheet, Game.assets.misc.dataAsset);
    Q.compileSheets(Game.assets.others.sheet, Game.assets.others.dataAsset);
    Q.compileSheets(Game.assets.bullet.sheet, Game.assets.bullet.dataAsset);
    Q.compileSheets(Game.assets.controls.sheet, Game.assets.controls.dataAsset);
    if (Game.settings.femaleDoctor.get()) {
      Q.compileSheets(Game.assets.hud_f.sheet, Game.assets.hud_f.dataAsset);
      Q.compileSheets(Game.assets.characters_f.sheet, Game.assets.characters_f.dataAsset);
    } else {
      Q.compileSheets(Game.assets.hud_m.sheet, Game.assets.hud_m.dataAsset);
      Q.compileSheets(Game.assets.characters_m.sheet, Game.assets.characters_m.dataAsset);
    }
    
    // first stage
    if (Game.settings.cookiesAccepted.get()) {
      return Game.stageScreen("start");
    } else {
      return Game.stageScreen("cookies");
    }
  }, {
    progressCallback: function(loaded, total) {
      var container, element;
      element = document.getElementById("loading-progress");
      element.style.width = Math.floor(loaded / total * 100) + "%";
      if (loaded === total) {
        container = document.getElementById("loading");
        return container.parentNode.removeChild(container);
      }
    }
  });

  Q = Game.Q;

  Q.AudioManager = {
    collection: [],
    muted: false,
    addMusic: function(audio, options) {
      if (Game.settings.musicEnabled.get()) {
        return this._add(audio, options);
      }
    },
    addSoundFx: function(audio, options) {
      if (Game.settings.soundFxEnabled.get()) {
        return this._add(audio, options);
      }
    },
    _add: function(audio, options) {
      var alreadyAdded, item;
      item = {
        audio: audio,
        options: options
      };
      if ((options != null ? options.loop : void 0) === true) {
        alreadyAdded = this.find(audio);
        if (alreadyAdded < 0) {
          this.collection.push(item);
        }
      }
      if (!this.muted) {
        return Q.audio.play(item.audio, item.options);
      }
    },
    remove: function(audio) {
      var indexToRemove;
      indexToRemove = null;
      indexToRemove = this.find(audio);
      if (indexToRemove >= 0) {
        Q.audio.stop(this.collection[indexToRemove].audio);
        return this.collection.splice(indexToRemove, 1);
      }
    },
    find: function(audio) {
      var index, item, j, len, ref;
      ref = this.collection;
      for (index = j = 0, len = ref.length; j < len; index = ++j) {
        item = ref[index];
        if (item.audio === audio) {
          return index;
        }
      }
      return -1;
    },
    playAll: function() {
      var item, j, len, ref, results;
      ref = this.collection;
      results = [];
      for (j = 0, len = ref.length; j < len; j++) {
        item = ref[j];
        results.push(Q.audio.play(item.audio, item.options));
      }
      return results;
    },
    stopAll: function() {
      return Q.audio.stop();
    },
    clear: function() {
      return this.collection = [];
    },
    mute: function() {
      this.muted = true;
      return this.stopAll();
    },
    unmute: function() {
      this.muted = false;
      return this.playAll();
    }
  };

  Q = Game.Q;

  Q.LevelParser = {
    // NB most of these methods modifies the global Game object
    default_load_level: function(stage, data_asset, bullets_per_gun) {
      var background, objects;
      // If no customisation is required, this encapsulates all level loading      

      // main map with collision
      Game.map = this.load_map(data_asset, Game.SPRITE_TILES, 0);
      stage.collisionLayer(Game.map);
      
      // background decorations
      background = this.load_map(data_asset, Game.SPRITE_NONE, 1);
      stage.insert(background);
      // all other objects (player, zombies, gun, health, door etc)
      objects = this.parse_objects(data_asset, []);
      this.load_objects(stage, objects, bullets_per_gun);
      // store level data for level summary
      Game.currentLevelData.health.available = stage.lists.Heart.length;
      return Game.currentLevelData.zombies.available = stage.lists.Zombie.length;
    },
    load_map: function(data_asset, sprite_type, layer_index) {
      return new Q.TileLayer({
        type: sprite_type,
        layerIndex: layer_index,
        dataAsset: data_asset,
        sheet: Game.assets.map.sheetName,
        tileW: Game.assets.map.tileSize,
        tileH: Game.assets.map.tileSize,
        z: 2
      });
    },
    parse_objects: function(dataAsset, ignore_objects) {
      var data, doc, fileExt, fileParts, item, j, len, name, name_lowercase, obj, objects, parser;
      fileParts = dataAsset.split(".");
      fileExt = fileParts[fileParts.length - 1].toLowerCase();
      if (fileExt === "tmx" || fileExt === "xml") {
        parser = new DOMParser();
        doc = parser.parseFromString(Q.asset(dataAsset), "application/xml");
        objects = doc.getElementsByTagName("object");
        data = [];
        for (j = 0, len = objects.length; j < len; j++) {
          obj = objects[j];
          name_lowercase = obj.getAttribute('name');
          // capitalise first letter
          name = name_lowercase.charAt(0).toUpperCase() + name_lowercase.slice(1);
          
          // legacy inconsistencies
          if (name === "Health") {
            name = "Heart";
          }
          if (indexOf.call(ignore_objects, name) < 0) {
            item = {
              name: name,
              x: obj.getAttribute('x') / Game.assets.map.tileSize,
              y: obj.getAttribute('y') / Game.assets.map.tileSize,
              w: obj.getAttribute('width') / Game.assets.map.tileSize,
              h: obj.getAttribute('height') / Game.assets.map.tileSize
            };
            data.push(item);
          }
        }
        return data;
      } else {
        throw "file type not supported";
      }
    },
    load_objects: function(stage, objects, bullets_per_gun) {
      var all_items, item, j, len, obj, player, randomBool, ref;
      all_items = [];
      for (j = 0, len = objects.length; j < len; j++) {
        obj = objects[j];
        if ((ref = obj.name) === "Key" || ref === "Gun" || ref === "Zombie" || ref === "Door" || ref === "Player" || ref === "Heart" || ref === "Health") {
          if (obj.name === "Gun") {
            // Add bullets
            item = [
              obj.name,
              Q.tilePos(obj.x,
              obj.y,
              {
                bullets: bullets_per_gun
              })
            ];
            all_items.push(item);
          } else if (obj.name === "Zombie") {
            // Face random direction
            randomBool = Math.floor(Math.random() * 2);
            console.log(randomBool);
            item = [
              obj.name,
              Q.tilePos(obj.x,
              obj.y,
              {
                startLeft: randomBool,
                canFallOff: false
              })
            ];
            all_items.push(item);
          } else if (obj.name === "Player") {
            // Player and camera together, get added differently
            Game.player = player = stage.insert(new Q.Player(Q.tilePos(obj.x, obj.y)));
            stage.add("viewport");
            Game.setCameraTo(stage, player);
          } else if (obj.name === "Door") {
            all_items.push([obj.name, Q.tilePos(obj.x, obj.y)]);
            
            // Add door button for gaze
            Game.add_door_button(stage, Q.tilePos(obj.x, obj.y));
          } else {
            item = [obj.name, Q.tilePos(obj.x, obj.y)];
            all_items.push(item);
          }
        } else {
          console.log(`Cannot create object: ${obj.name}`);
        }
      }
      return stage.loadAssets(all_items);
    }
  };

  Q = Game.Q;

  Q.component("gun", {
    added: function() {
      var p;
      Q.input.on("fire", this.entity, "fireGun");
      p = this.entity.p;
      // animations
      p.sheet = "player_with_gun";
      p.sprite = "playerWithGun";
      this.entity.play("stand");
      // do not allow to fire in series
      return p.nextFireTimeout = 0;
    },
    destroyed: function() {
      return Q.input.off("fire", this.entity);
    },
    extend: {
      gunStep: function(dt) {
        if (this.p.nextFireTimeout > 0) {
          return this.p.nextFireTimeout = Math.max(this.p.nextFireTimeout - dt, 0);
        }
      },
      fireGun: function() {
        var bullet, delta;
        if (this.p.nextFireTimeout === 0) {
          this.p.nextFireTimeout = 0.5;
          // fire
          if (Q.state.get("bullets") > 0) {
            if (this.p.direction === "left") {
              delta = -15;
            } else {
              delta = 15;
            }
            Q.AudioManager.addSoundFx(Game.audio.gunShot);
            bullet = this.stage.insert(new Q.Bullet({
              x: this.p.x + delta,
              y: this.p.y + 3,
              direction: this.p.direction
            }));
            
            // update counter
            if (!Game.settings.unlimitedAmmo.get()) {
              return Q.state.dec("bullets", 1);
            }
          } else {
            return Game.infoLabel.outOfBullets();
          }
        }
      }
    }
  });

  Q = Game.Q;

  Q.component("zombieAI", {
    added: function() {
      var p;
      p = this.entity.p;
      p.fullSpeed = 60 * Game.settings.zombieSpeed.get();
      if (p.startLeft) {
        p.vx = p.fullSpeed;
      } else {
        p.vx = -p.fullSpeed;
      }
      return p.audioTimeout = 0;
    },
    extend: {
      zombieStep: function(dt) {
        var cliffAhead, currentlyChasing, dirX, ground, inFront, inFrontPlayer, inFrontTile, nextTile, playerInvincible, stopChasing;
        // some AI - always try to catch player
        this.canSeeThePlayer(); // create @canSeeThePlayerObj object
        
        // stop chasing while player invincible
        playerInvincible = this.isPlayerInvincible();
        if (playerInvincible) {
          this.p.canSeeThePlayerTimeout = 0;
        } else if (this.canSeeThePlayerObj.status) {
          // I see the player, I will remember that for X sec
          this.p.canSeeThePlayerTimeout = 2;
          if (this.canSeeThePlayerObj.playAudio) {
            if (this.p.audioTimeout === 0) {
              Q.AudioManager.addSoundFx(Game.audio.zombieNotice);
              this.play("attack", 10);
              this.p.audioTimeout = 10;
            }
          }
          if ((this.canSeeThePlayerObj.left && this.p.vx > 0) || (this.canSeeThePlayerObj.right && this.p.vx < 0)) {
            // enemy goes in wrong direction, change it
            this.p.vx = -Math.sign(this.p.vx) * this.p.fullSpeed;
          }
        } else {
          // run timeout
          this.p.canSeeThePlayerTimeout = Math.max(this.p.canSeeThePlayerTimeout - dt, 0);
        }
        // count always
        this.p.audioTimeout = Math.max(this.p.audioTimeout - dt, 0);
        // locate gap and turn back
        dirX = this.p.vx / Math.abs(this.p.vx); // or Math.sign(@p.vx) !
        ground = Q.stage().locate(this.p.x, this.p.y + this.p.h / 2 + 1, Game.SPRITE_TILES);
        nextTile = Q.stage().locate(this.p.x + dirX * this.p.w / 2 + dirX, this.p.y + this.p.h / 2 + 1, Game.SPRITE_TILES);
        inFrontTile = Q.stage().locate(this.p.x + dirX * this.p.w / 2 + dirX, this.p.y, Game.SPRITE_TILES);
        inFrontPlayer = Q.stage().locate(this.p.x + dirX * this.p.w / 2 + dirX, this.p.y, Game.SPRITE_PLAYER);
        inFront = inFrontTile || inFrontPlayer;
        cliffAhead = !nextTile && ground;
        // if player is invincible, we'll stop chasing as soon as attack animation finished
        stopChasing = playerInvincible && this.p.animation !== "attack";
        currentlyChasing = !stopChasing && (this.canSeeThePlayerObj.status || this.p.canSeeThePlayerTimeout > 0);
        if (cliffAhead) {
          if (!currentlyChasing) {
            if (this.p.vx > 0) {
              // turn around 
              this.p.vx = -Math.sign(this.p.vx) * this.p.fullSpeed;
            } else {
              // turn around 
              if (this.p.flip) {
                this.p.vx = this.p.fullSpeed;
              } else {
                this.p.vx = -this.p.fullSpeed;
              }
            }
          } else if (currentlyChasing && !this.p.canFallOff) {
            // keep facing player, but don't fall off
            this.p.vx = 0;
          }
        }
        // if there's an obstacle in front
        if (inFront && !currentlyChasing) {
          // turn around 
          this.p.vx = -Math.sign(this.p.vx) * this.p.fullSpeed;
        }
        // set the correct direction of sprite
        return this.flip();
      },
      flip: function() {
        if (Math.abs(this.p.vx) > 0) {
          if (this.p.vx > 0) {
            return this.p.flip = false;
          } else {
            return this.p.flip = "x";
          }
        }
      },
      isPlayerInvincible: function() {
        var player;
        player = Game.player.p;
        return ((player != null ? player.isDestroyed : void 0) == null) && player.timeInvincible > 0;
      },
      canSeeThePlayer: function() {
        var isCloseFromLeft, isCloseFromRight, isTheSameY, lineOfSight, oldObj, player;
        player = Game.player.p;
        lineOfSight = 350;
        oldObj = this.canSeeThePlayerObj;
        this.canSeeThePlayerObj = {
          playAudio: true,
          status: false
        };
        if (!Game.settings.zombiesChase.get()) {
          return;
        }
        if ((oldObj != null ? oldObj.status : void 0) === true) {
          this.canSeeThePlayerObj.playAudio = false;
        }
        if (Game.player.isDestroyed != null) {
          return;
        }
        // is player on the same level as enemy?
        isTheSameY = player.y > this.p.y - 10 && player.y < this.p.y + 10;
        // is player in the near of the enemy?
        this.canSeeThePlayerObj.left = isCloseFromLeft = (player.x > this.p.x - lineOfSight) && player.x < this.p.x;
        this.canSeeThePlayerObj.right = isCloseFromRight = (player.x < this.p.x + lineOfSight) && player.x > this.p.x;
        if (isTheSameY && (isCloseFromLeft || isCloseFromRight)) {
          this.canSeeThePlayerObj.status = true;
        } else {
          this.canSeeThePlayerObj.status = false;
          this.canSeeThePlayerObj.playAudio = true;
        }
      }
    }
  });

  Q = Game.Q;

  Q.scene("about", function(stage) {
    var authors, button, buttonTextSize, desc, description, label, title, titleContainer, y_pad;
    // add title
    y_pad = Q.height / 20;
    titleContainer = stage.insert(new Q.UI.Container({
      x: Q.width / 2,
      y: Q.height / 2
    }));
    // description = "Imagine, what if the cure exists?\n"
    description = "Heal 'em all was designed and written by Kris Urbas (programming, story)\n";
    description += "and Pawel Madeja (graphics) and was one of the GitHub Game Jam 2013 winners.\n";
    description += "\n";
    description += "They kindly gave permission for SpecialEffect to adapt the game for an\n";
    description += "eye gaze audience in 2019. \n";
    description += "\n";
    description += "The game uses the Quintus game engine under the MIT license, \n";
    description += "and audio from https://opengameart.org/";
    // TODO link to https://raw.githubusercontent.com/cykod/Quintus/master/MIT-LICENSE.txt
    // probably a link to github where we can more easily detail things / give links
    desc = titleContainer.insert(new Q.UI.Text({
      x: 0,
      y: 0,
      align: 'center',
      label: description,
      color: "#000000",
      family: "Jolly Lodger",
      size: Styles.fontsize5
    }));
    // panel
    titleContainer.insert(new Q.UI.Container({
      x: 0,
      y: 0,
      w: desc.p.w * 1.1,
      h: desc.p.h * 1.1,
      z: desc.p.z - 1,
      fill: "#e3ecf933",
      radius: 8,
      type: Q.SPRITE_UI | Q.SPRITE_DEFAULT
    }));
    title = titleContainer.insert(new Q.UI.Text({
      x: 0,
      y: desc.p.y - desc.p.h / 2,
      label: "Heal'em All",
      color: "#f2da38",
      family: "Jolly Lodger",
      size: Styles.fontsize13
    }));
    title.p.y = title.p.y - title.p.h / 2 - y_pad;
    title.size();
    // button
    label = "Back";
    buttonTextSize = Q.ctx.measureText(label);
    button = titleContainer.insert(new Q.UI.Button({
      x: 0,
      y: desc.p.y + desc.p.h / 2,
      w: buttonTextSize.width * 1.3,
      h: 80,
      fill: "#c4da4a",
      radius: 10,
      fontColor: "#353b47",
      font: "400 58px Jolly Lodger",
      label: label,
      keyActionName: "escape",
      type: Q.SPRITE_UI | Q.SPRITE_DEFAULT
    }));
    button.p.y = button.p.y + button.p.h / 2 + y_pad * 2;
    titleContainer.fit();
    // authors
    authors = stage.insert(new Q.UI.Authors());
    return button.on("click", function(e) {
      return Game.stageLevelSelectScreen();
    });
  });

  Q = Game.Q;

  Q.scene("achievement_unlocked", function(stage) {
    var button, marginY, message;
    message = stage.options.message;
    // some math
    marginY = Q.height * 0.25;
    // audio
    Q.AudioManager.stopAll();
    // add title
    stage.insert(new Q.UI.Text({
      x: Q.width / 2,
      y: marginY / 2,
      label: "Achievement Unlocked!",
      color: "#f2da38",
      family: "Jolly Lodger",
      size: Styles.fontsize14
    }));
    // message
    stage.insert(new Q.UI.Text({
      x: Q.width / 2,
      y: Q.height / 2,
      label: message,
      color: "#c4da4a",
      family: "Boogaloo",
      size: Styles.fontsize5,
      align: "center"
    }));
    // button
    button = stage.insert(new Q.UI.Button({
      x: Q.width / 2,
      y: Q.height - marginY / 2,
      w: Q.width / 3,
      h: 70,
      fill: "#c4da4a",
      radius: 10,
      fontColor: "#353b47",
      font: "400 58px Jolly Lodger",
      label: "Back to all levels",
      keyActionName: "confirm",
      type: Q.SPRITE_UI | Q.SPRITE_DEFAULT
    }));
    // Narrate score
    if (Game.settings.narrationEnabled.get()) {
      responsiveVoice.speak(message);
    }
    return button.on("click", function(e) {
      return Game.stageLevelSelectScreen();
    });
  });

  Q = Game.Q;

  Q.scene("confirm_reset", function(stage) {
    var buttonCancel, buttonHeight, buttonReset, button_width, cancel_text, columnInP, columnWidth, columnsNo, font, gutterX, gutterXinP, j, len, marginX, marginXinP, marginY, msg, msgLabel, msgLines, msgMaxLength, msgOrigLength, reset_text, setting, textsize, user_settings;
    // audio
    Q.AudioManager.stopAll();
    font = "400 58px Jolly Lodger";
    Q.ctx.font = font;
    reset_text = "Yes, reset everything";
    cancel_text = "Cancel";
    textsize = Q.ctx.measureText(reset_text);
    button_width = textsize.width * 1.2;
    // some math
    marginY = Q.height * 0.25;
    buttonHeight = 80;
    marginXinP = 20; // %
    gutterXinP = 8; // %
    columnsNo = 2;
    // layout math
    columnInP = (100 - (marginXinP * 2) - (columnsNo - 1) * gutterXinP) / columnsNo; // 24%
    marginX = Q.width * marginXinP * 0.01;
    gutterX = Q.width * gutterXinP * 0.01;
    columnWidth = Q.width * columnInP * 0.01;
    // audio
    Q.AudioManager.stopAll();
    msgLabel = "Are you sure you want to reset all settings to default?";
    
    // message
    msg = stage.insert(new Q.UI.Text({
      x: Q.width / 2,
      y: Q.height / 4 + marginY / 4,
      label: msgLabel,
      color: "#c4da4a",
      family: "Boogaloo",
      size: Styles.fontsize6,
      align: "center"
    }));
    // sub-message, with word wrap, tells users what they'll lose
    // (if nothing, then don't display this, but let them continue with the no-op)
    user_settings = Game.getUserSettings();
    if (user_settings.length > 0) {
      msgLabel = "This will affect: ";
      msgOrigLength = msgLabel.length;
      msgMaxLength = 80;
      msgLines = 1;
      for (j = 0, len = user_settings.length; j < len; j++) {
        setting = user_settings[j];
        // Append to message, respecting word wrap
        if (msgLabel.length > msgOrigLength) {
          msgLabel += ", ";
        }
        if (msgLabel.length > msgMaxLength * msgLines) {
          msgLabel += "\n";
          msgLines++;
        }
        msgLabel += setting;
      }
      
      // message
      msg = stage.insert(new Q.UI.Text({
        x: Q.width / 2,
        y: Q.height / 2,
        label: msgLabel,
        color: "#c4da4a",
        family: "Boogaloo",
        size: Styles.fontsize4,
        align: "center"
      }));
    }
    buttonCancel = stage.insert(new Q.UI.Button({
      y: Q.height - marginY,
      w: button_width,
      h: buttonHeight,
      fill: "#c4da4a",
      radius: 10,
      fontColor: "#353b47",
      font: font,
      label: "Cancel",
      keyActionName: "confirm",
      type: Q.SPRITE_UI | Q.SPRITE_DEFAULT
    }));
    buttonCancel.p.x = Q.width / 2 + buttonCancel.p.w / 2 + 40;
    buttonCancel.on("click", function(e) {
      return Game.stageScreen("settings_menu");
    });
    buttonReset = stage.insert(new Q.UI.Button({
      y: Q.height - marginY,
      w: button_width,
      h: buttonHeight,
      fill: "#f2da38",
      radius: 10,
      fontColor: "#353b47",
      font: font,
      label: "Yes, reset everything",
      type: Q.SPRITE_UI | Q.SPRITE_DEFAULT
    }));
    buttonReset.p.x = Q.width / 2 - buttonReset.p.w / 2 - 40;
    return buttonReset.on("click", function(e) {
      Game.resetAllSettings();
      return Game.stageScreen("settings_menu");
    });
  });

  Q = Game.Q;

  Q.scene("controls", function(stage) {
    var button, cell1, cell2, cell3, cell4, columnInP, columnWidth, columnsNo, gutterX, gutterXinP, marginX, marginXinP, marginY, numberpad, row2offset, rowHeight, sprite, step1text, step2text, step3text, step4text, title, x_pad;
    // some math
    marginY = Q.height * 0.15;
    marginXinP = 10; // %
    gutterXinP = 8; // %
    columnsNo = 2;
    // layout math
    columnInP = (100 - (marginXinP * 2) - (columnsNo - 1) * gutterXinP) / columnsNo; // 24%
    marginX = Q.width * marginXinP * 0.01;
    gutterX = Q.width * gutterXinP * 0.01;
    columnWidth = Q.width * columnInP * 0.01;
    rowHeight = Q.height * 0.3;
    // audio
    Q.AudioManager.stopAll();
    Q.AudioManager.clear();
    // add title
    title = stage.insert(new Q.UI.Text({
      x: Q.width / 2,
      y: marginY,
      label: "How to healem",
      color: "#f2da38",
      family: "Jolly Lodger",
      size: Styles.fontsize9
    }));
    // add cells, 2x2
    x_pad = -50; // to account for images on right of centralised text
    cell1 = stage.insert(new Q.UI.Container({
      x: marginX + columnWidth / 2 + x_pad,
      y: Q.height / 2 - rowHeight / 2 + title.p.h,
      w: columnWidth,
      h: rowHeight
    }));
    cell2 = stage.insert(new Q.UI.Container({
      x: cell1.p.x + gutterX + columnWidth + x_pad,
      y: Q.height / 2 - rowHeight / 4 + title.p.h,
      w: columnWidth,
      h: rowHeight
    }));
    cell3 = stage.insert(new Q.UI.Container({
      x: marginX + columnWidth / 2 + x_pad,
      y: Q.height / 2 + rowHeight / 4 + title.p.h,
      w: columnWidth,
      h: rowHeight
    }));
    cell4 = stage.insert(new Q.UI.Container({
      x: cell1.p.x + gutterX + columnWidth + x_pad,
      y: Q.height / 2 + rowHeight / 2 + title.p.h,
      w: columnWidth,
      h: rowHeight
    }));
    
    // add 1 step
    numberpad = 40;
    row2offset = 30;
    step1text = cell1.insert(new Q.UI.Text({
      x: 0,
      y: -100,
      label: "Explore the graveyard",
      color: "#9ca2ae",
      family: "Boogaloo",
      size: Styles.fontsize4
    }));
    cell1.insert(new Q.UI.Text({
      x: step1text.p.x - step1text.p.w / 2 - numberpad,
      y: step1text.p.y,
      label: "1.",
      color: "#f2da38",
      family: "Boogaloo",
      size: Styles.fontsize7
    }));
    cell1.insert(new Q.Sprite({
      x: step1text.p.x + step1text.p.w / 2 + 160,
      y: step1text.p.y - 15,
      sheet: "controls_eyegaze"
    }));
    // add 2 step
    step2text = cell2.insert(new Q.UI.Text({
      x: 0,
      y: step1text.p.y,
      label: "Find Healing Gun",
      color: "#9ca2ae",
      family: "Boogaloo",
      size: Styles.fontsize4
    }));
    cell2.insert(new Q.UI.Text({
      x: step2text.p.x - step2text.p.w / 2 - numberpad,
      y: step2text.p.y,
      label: "2.",
      color: "#f2da38",
      family: "Boogaloo",
      size: Styles.fontsize7
    }));
    sprite = cell2.insert(new Q.Sprite({
      x: step2text.p.x + step2text.p.w / 2 + 120,
      y: step2text.p.y,
      sheet: "controls_gun"
    }));
    // add 3 step
    step3text = cell3.insert(new Q.UI.Text({
      x: step1text.p.x,
      y: step1text.p.y,
      label: "Shoot the zombies!",
      color: "#9ca2ae",
      family: "Boogaloo",
      size: Styles.fontsize4
    }));
    cell3.insert(new Q.UI.Text({
      x: step3text.p.x - step3text.p.w / 2 - numberpad,
      y: step3text.p.y,
      label: "3.",
      color: "#f2da38",
      family: "Boogaloo",
      size: Styles.fontsize7
    }));
    cell3.insert(new Q.Sprite({
      x: step3text.p.x + step3text.p.w / 2 + 100,
      y: step3text.p.y,
      sheet: "controls_zombie"
    }));
    step4text = cell4.insert(new Q.UI.Text({
      x: step2text.p.x,
      y: step1text.p.y,
      label: "Find the exit",
      color: "#9ca2ae",
      family: "Boogaloo",
      size: Styles.fontsize4
    }));
    cell4.insert(new Q.UI.Text({
      x: step4text.p.x - step4text.p.w / 2 - numberpad,
      y: step4text.p.y,
      label: "4.",
      color: "#f2da38",
      family: "Boogaloo",
      size: Styles.fontsize7
    }));
    cell4.insert(new Q.Sprite({
      x: step4text.p.x + step4text.p.w / 2 + 120,
      y: step4text.p.y,
      sheet: "controls_door"
    }));
    // button
    button = stage.insert(new Q.UI.Button({
      x: Q.width / 2,
      y: Q.height - marginY,
      w: Q.width / 2,
      h: 120,
      fill: "#c4da4a",
      radius: 10,
      fontColor: "#353b47",
      font: "400 58px Jolly Lodger",
      label: "Give me some zombies",
      keyActionName: "confirm",
      type: Q.SPRITE_UI | Q.SPRITE_DEFAULT
    }));
    return button.on("click", function(e) {
      return Game.stageLevel(1);
    });
  });

  Q = Game.Q;

  Q.scene("controls_keyboard", function(stage) {
    var button, column1Container, column2Container, column3Container, columnInP, columnWidth, columnsNo, gutterX, gutterXinP, marginX, marginXinP, marginY, step1text1, step1text2;
    // some math
    marginY = Q.height * 0.25;
    marginXinP = 20; // %
    gutterXinP = 8; // %
    columnsNo = 3;
    // layout math
    columnInP = (100 - (marginXinP * 2) - (columnsNo - 1) * gutterXinP) / columnsNo; // 24%
    marginX = Q.width * marginXinP * 0.01;
    gutterX = Q.width * gutterXinP * 0.01;
    columnWidth = Q.width * columnInP * 0.01;
    // audio
    Q.AudioManager.stopAll();
    Q.AudioManager.clear();
    // add title
    stage.insert(new Q.UI.Text({
      x: Q.width / 2,
      y: marginY / 2,
      label: "How to healem in three steps",
      color: "#f2da38",
      family: "Jolly Lodger",
      size: Styles.fontsize9
    }));
    // add 3 columns
    column1Container = stage.insert(new Q.UI.Container({
      x: marginX + columnWidth / 2,
      y: Q.height / 2
    }));
    column2Container = stage.insert(new Q.UI.Container({
      x: column1Container.p.x + gutterX + columnWidth,
      y: Q.height / 2
    }));
    column3Container = stage.insert(new Q.UI.Container({
      x: column2Container.p.x + gutterX + columnWidth,
      y: Q.height / 2
    }));
    // add 1 step
    step1text1 = column1Container.insert(new Q.UI.Text({
      x: 0,
      y: -140,
      label: "1st",
      color: "#ec655d",
      family: "Boogaloo",
      size: Styles.fontsize2
    }));
    step1text2 = column1Container.insert(new Q.UI.Text({
      x: 0,
      y: -100,
      label: "Move with arrows",
      color: "#9ca2ae",
      family: "Boogaloo",
      size: Styles.fontsize4
    }));
    column1Container.insert(new Q.Sprite({
      x: 0,
      y: 0,
      sheet: "ui_controls_1"
    }));
    // add 2 step
    column2Container.insert(new Q.UI.Text({
      x: 0,
      y: step1text1.p.y,
      label: "2nd",
      color: "#ec655d",
      family: "Boogaloo",
      size: Styles.fontsize2
    }));
    column2Container.insert(new Q.UI.Text({
      x: 0,
      y: step1text2.p.y,
      label: "Find Healing Gun",
      color: "#9ca2ae",
      family: "Boogaloo",
      size: Styles.fontsize4
    }));
    column2Container.insert(new Q.Sprite({
      x: 0,
      y: 0,
      sheet: "ui_controls_2"
    }));
    // add 3 step
    column3Container.insert(new Q.UI.Text({
      x: 0,
      y: step1text1.p.y,
      label: "3rd",
      color: "#ec655d",
      family: "Boogaloo",
      size: Styles.fontsize2
    }));
    column3Container.insert(new Q.UI.Text({
      x: 0,
      y: step1text2.p.y,
      label: "Use your Gun!",
      color: "#9ca2ae",
      family: "Boogaloo",
      size: Styles.fontsize4
    }));
    column3Container.insert(new Q.Sprite({
      x: 0,
      y: 0,
      sheet: "ui_controls_3"
    }));
    // button
    button = stage.insert(new Q.UI.Button({
      x: Q.width / 2,
      y: Q.height - marginY,
      w: Q.width / 2,
      h: 70,
      fill: "#c4da4a",
      radius: 10,
      fontColor: "#353b47",
      font: "400 58px Jolly Lodger",
      label: "Give me some zombies",
      keyActionName: "confirm",
      type: Q.SPRITE_UI | Q.SPRITE_DEFAULT
    }));
    return button.on("click", function(e) {
      return Game.stageLevel(1);
    });
  });

  Q = Game.Q;

  Q.scene("cookies", function(stage) {
    var button, desc, description, label, titleContainer;
    titleContainer = stage.insert(new Q.UI.Container({
      x: Q.width / 2,
      y: Q.height / 2
    }));
    titleContainer.insert(new Q.UI.Container({
      x: 0,
      y: 0,
      w: Q.width,
      h: Q.height,
      z: 50,
      fill: "rgba(0,0,0,0.5)"
    }));
    titleContainer.insert(new Q.UI.Text({
      x: 0,
      y: -Q.height / 4,
      label: "Cookies",
      color: "#f2da38",
      family: "Jolly Lodger",
      size: Styles.fontsize11
    }));
    description = "This site uses cookies and local data storage to\n";
    description += "save your game progress and preferences, to enable\n";
    description += "narration services and to analyse our traffic.";
    desc = titleContainer.insert(new Q.UI.Text({
      x: 0,
      y: 0,
      align: 'center',
      label: description,
      color: "#9ca2ae",
      family: "Jolly Lodger",
      size: Styles.fontsize5
    }));
    label = "Accept";
    button = titleContainer.insert(new Q.UI.Button({
      x: 0,
      y: Q.height / 4,
      w: Q.width / 3,
      h: 80,
      fill: "#c4da4a",
      radius: 10,
      fontColor: "#353b47",
      font: "400 58px Jolly Lodger",
      label: label,
      keyActionName: "confirm",
      type: Q.SPRITE_UI | Q.SPRITE_DEFAULT
    }));
    button.on("click", function(e) {
      Game.settings.cookiesAccepted.set("true");
      return Game.stageScreen("start");
    });
    return titleContainer.fit();
  });

  Q = Game.Q;

  Q.scene("gameOver", function(stage) {
    var buttonBack, buttonTryAgain, marginY, msg, offset_y, remaining_height, title, y_per_element;
    // some math
    marginY = Q.height * 0.25;
    // audio
    Q.AudioManager.stopAll();
    // add title
    title = stage.insert(new Q.UI.Text({
      x: Q.width / 2,
      y: marginY,
      label: "Game Over",
      color: "#f2da38",
      family: "Jolly Lodger",
      size: Styles.fontsize14
    }));
    // Split up rest of space equally
    offset_y = title.p.y / 2 + title.p.h / 2;
    remaining_height = Q.height - offset_y;
    y_per_element = remaining_height / 4;
    // message
    msg = stage.insert(new Q.UI.Text({
      x: Q.width / 2,
      y: Q.height / 2,
      label: "Oh no, you died!\nLooks like the zombies won't be healed today...",
      color: "#c4da4a",
      family: "Boogaloo",
      size: Styles.fontsize5,
      align: "center"
    }));
    // button next
    buttonTryAgain = stage.insert(new Q.UI.Button({
      y: Q.height - marginY,
      w: Q.width / 4,
      h: 70,
      fill: "#c4da4a",
      radius: 10,
      fontColor: "#353b47",
      font: "400 58px Jolly Lodger",
      label: "Try again",
      keyActionName: "confirm",
      type: Q.SPRITE_UI | Q.SPRITE_DEFAULT
    }));
    buttonTryAgain.p.x = Q.width / 2 + buttonTryAgain.p.w / 2 + 40;
    buttonTryAgain.on("click", function(e) {
      return Game.stageLevel(Q.state.get("currentLevel"));
    });
    // button back
    buttonBack = stage.insert(new Q.UI.Button({
      y: Q.height - marginY,
      w: Q.width / 4,
      h: 70,
      fill: "#f2da38",
      radius: 10,
      fontColor: "#353b47",
      font: "400 58px Jolly Lodger",
      label: "Main menu",
      type: Q.SPRITE_UI | Q.SPRITE_DEFAULT
    }));
    buttonBack.p.x = Q.width / 2 - buttonBack.p.w / 2 - 40;
    return buttonBack.on("click", function(e) {
      return Game.stageLevelSelectScreen();
    });
  });

  Q = Game.Q;

  Q.scene("gaze_overlay", function(stage) {
    var base_width, btnJumpLeft, btnJumpRight, btnLeft, btnRight, btnShoot, camera_offset, d, h, jump_xoffset, margin, min_clearance, onChangeHidden, onClick, onTouch, onTouchEnd, p, scale, shoot_p, shoot_points_normalised, top_of_buttons, w, width, x_centre, x_left, x_right, y_lower, y_shoot, y_upper;
    scale = Number.parseFloat(Game.settings.uiScale.get());
    base_width = Q.width / 10;
    width = base_width * scale;
    w = width;
    h = width;
    margin = w / 15;
    onClick = (action) => {
      return (e) => {
        if (action) {
          Q.inputs[action] = 1;
          return Q.input.trigger(action);
        }
      };
    };
    onTouch = (action) => {
      return (e) => {
        if (action) {
          return Q.inputs[action] = 1;
        }
      };
    };
    onTouchEnd = (action) => {
      return (e) => {
        if (action) {
          return Q.inputs[action] = 0;
        }
      };
    };
    // (drew in inkscape, exported points)
    shoot_points_normalised = [[-0.55601, -0.06244], [-0.52346, 0.27963], [-0.39846, 0.42963], [-0.16236, 0.53631], [0.13835, 0.53221], [0.40483, 0.37777], [0.51227, 0.21024], [0.56227, 0.06024], [0.52017, -0.15927], [0.33858, -0.38187], [0.0781, -0.50214], [-0.21649, -0.44501], [-0.44801, -0.29167]];
    // scale shapes up
    shoot_p = (function() {
      var j, len, results;
      results = [];
      for (j = 0, len = shoot_points_normalised.length; j < len; j++) {
        p = shoot_points_normalised[j];
        results.push([p[0] * w * .9, p[1] * h * .9]);
      }
      return results;
    })();
    // rightjump_p = ([p[0]*w*.9, p[1]*h*.9] for p in rightjump_normalised)
    // leftjump_p = ([p[0]*w*.9, p[1]*h*.9] for p in leftjump_normalised)

    // interact zone for jump buttons is ~90% inside
    // rightjump_p_interact = ([p[0]*.9, p[1]*.9] for p in rightjump_p)
    // leftjump_p_interact = ([p[0]*.9, p[1]*.9] for p in leftjump_p)  

    // positioning
    // lower buttons (left, right, shoot) should centre vertically on platform player is stood on
    y_lower = Q.height / 2 + Game.assets.map.tileSize / 2;
    // shoot is even lower, to leave centre as rest position
    y_shoot = y_lower + Game.assets.map.tileSize * 1.5;
    // upper buttons (jump) centre just above next platform, for scale = 1, 
    y_upper = y_lower - (3 + scale) * Game.assets.map.tileSize;
    camera_offset = -0.4 * Game.assets.map.tileSize;
    // For small buttons, we want layout to be square
    x_left = Q.width / 2 + camera_offset - (y_lower - y_upper) / 2;
    x_right = Q.width / 2 + camera_offset + (y_lower - y_upper) / 2;
    x_centre = Q.width / 2 + camera_offset;
    
    // ... but for larger buttons, this will result in unnecessary overlap
    x_left = Math.min(Q.width / 2 + camera_offset - (width + margin * 2), x_left);
    x_right = Math.max(Q.width / 2 + camera_offset + (width + margin * 2));
    
    // we want direction+jump arrows to be left-aligned, not centre-aligned
    jump_xoffset = w / 30;
    btnLeft = new Q.UI.ArrowDwellButton({
      x: x_left,
      y: y_lower,
      h: h,
      w: w,
      faces_left: true,
      hover_action: "left"
    });
    btnRight = new Q.UI.ArrowDwellButton({
      x: x_right,
      y: y_lower,
      w: w,
      h: h,
      faces_left: false,
      hover_action: "right"
    });
    btnJumpLeft = new Q.UI.JumpDwellButton({
      x: x_left + jump_xoffset,
      y: y_upper,
      w: w,
      h: h,
      faces_left: true,
      dwell_action: "jumpleft"
    });
    btnJumpRight = new Q.UI.JumpDwellButton({
      x: x_right - jump_xoffset,
      y: y_upper,
      w: w,
      h: h,
      faces_left: false,
      dwell_action: "jumpright"
    });
    // shoot button 
    btnShoot = new Q.UI.PolygonButton({
      x: x_centre,
      y: y_shoot,
      w: w,
      h: h,
      z: 1,
      type: Q.SPRITE_UI | Q.SPRITE_DEFAULT,
      fill: "#c4da4a",
      radius: 10,
      fontColor: "#000000",
      font: "400 58px Jolly Lodger",
      label: "shoot",
      points: shoot_p
    });
    btnShoot.p.opacity = Number.parseFloat(Game.settings.uiOpacity.get());
    btnShoot.on("click", function(e) {
      Q.inputs["fire"] = 1;
      return Q.input.trigger("fire");
    });
    onChangeHidden = (btn) => {
      return () => {
        return btn.p.hidden = !Q.state.get("hasGun");
      };
    };
    btnShoot.p.hidden = !Q.state.get("hasGun");
    Q.state.on("change.hasGun", onChangeHidden(btnShoot));
    // make sure jump buttons haven't gone off top of screen
    min_clearance = 0;
    top_of_buttons = btnJumpRight.p.y - btnJumpRight.p.h / 2;
    if (top_of_buttons < min_clearance) {
      d = min_clearance - top_of_buttons;
      btnJumpRight.p.y += d;
      btnJumpLeft.p.y += d;
    }
    // Add everything to the stage
    stage.insert(btnLeft);
    stage.insert(btnRight);
    stage.insert(btnJumpLeft);
    stage.insert(btnJumpRight);
    return stage.insert(btnShoot);
  });

  Q = Game.Q;

  Q.scene("hud", function(stage) {
    var bulletsContainer, bulletsImg, enemiesContainer, healthContainer, healthImg, infoContainer, keyContainer, keyImg, marginBottomButtons, menuButton, pauseButton, playerAvatar;
    // stage.insert new Q.UI.RadialGradient()
    stage.insert(new Q.UI.LinearGradient());
    // doctor's comments
    Game.playerAvatar = playerAvatar = stage.insert(new Q.UI.PlayerAvatar({
      z: 10
    }));
    infoContainer = stage.insert(new Q.UI.Container({
      y: 40,
      z: 10,
      fill: "#fff"
    }));
    Game.infoLabel = infoContainer.insert(new Q.UI.InfoLabel({
      container: infoContainer,
      offsetLeft: playerAvatar.p.w
    }));
    // enemies counter
    enemiesContainer = stage.insert(new Q.UI.Container({
      y: 40,
      z: 10,
      fill: "#232322"
    }));
    enemiesContainer.insert(new Q.UI.EnemiesCounter());
    enemiesContainer.fit(0, 8);
    enemiesContainer.p.x = Q.width - enemiesContainer.p.w / 2 - 60;
    stage.insert(new Q.UI.EnemiesAvatar({
      z: 12
    }));
    // bullets counter
    bulletsContainer = stage.insert(new Q.UI.Container({
      y: 40,
      z: 10,
      fill: "#232322"
    }));
    bulletsImg = bulletsContainer.insert(new Q.UI.BulletsImg());
    bulletsContainer.insert(new Q.UI.BulletsCounter({
      img: bulletsImg.p
    }));
    bulletsContainer.fit(0, 8);
    bulletsContainer.p.x = enemiesContainer.p.x - enemiesContainer.p.w / 2 - bulletsContainer.p.w / 2 - 20 + 30;
    // health counter
    healthContainer = stage.insert(new Q.UI.Container({
      y: 40,
      z: 10,
      fill: "#232322"
    }));
    Game.healthImg = healthImg = healthContainer.insert(new Q.UI.HealthImg());
    healthContainer.insert(new Q.UI.HealthCounter({
      img: healthImg.p
    }));
    healthContainer.fit(0, 8);
    healthContainer.p.x = bulletsContainer.p.x - bulletsContainer.p.w / 2 - healthContainer.p.w / 2 - 20;
    // inventory key
    keyContainer = stage.insert(new Q.UI.Container({
      y: 40,
      z: 10,
      fill: "#232322"
    }));
    keyImg = keyContainer.insert(new Q.UI.InventoryKey());
    keyContainer.fit(5, 8);
    keyContainer.p.x = healthContainer.p.x - healthContainer.p.w / 2 - keyContainer.p.w / 2 - 34;
    // Buttons
    marginBottomButtons = Q.height * 0.1;
    pauseButton = stage.insert(new Q.UI.PauseButton({
      x: marginBottomButtons,
      y: Q.height - marginBottomButtons,
      isSmall: false
    }));
    menuButton = stage.insert(new Q.UI.MenuButton({
      x: Q.width - marginBottomButtons,
      y: Q.height - marginBottomButtons,
      isSmall: false
    }));
    return menuButton.on("click", function(e) {
      return Game.stageLevelSelectScreen();
    });
  });

  Q = Game.Q;

  Q.scene("hud_nav_only", function(stage) {
    var marginBottomButtons, menuButton, pauseButton;
    // Buttons
    marginBottomButtons = Q.height * 0.1;
    pauseButton = stage.insert(new Q.UI.PauseButton({
      x: marginBottomButtons,
      y: Q.height - marginBottomButtons,
      isSmall: false
    }));
    menuButton = stage.insert(new Q.UI.MenuButton({
      x: Q.width - marginBottomButtons,
      y: Q.height - marginBottomButtons,
      isSmall: false
    }));
    return menuButton.on("click", function(e) {
      return Q.stageScene("restartOptions");
    });
  });

  Q = Game.Q;

  Q.scene("levelSelectMore", function(stage) {
    var aboutButton, arrow, authors, button, columnInP, columnWidth, columnsNo, container, cursorButton, enabled, fontsize, gutterX, gutterXinP, gutterY, gutterYinP, h, i, item, j, l, len, level, level_name, m, marginX, marginXinP, marginY, marginYinP, max_pages, menuButton, name_width, pauseButton, ref, ref1, rowHeight, stars, starsX, starsY, w, x, x_sep, y;
    // audio
    Q.AudioManager.stopAll();
    Q.AudioManager.clear();
    // layout params
    marginXinP = 20; // %
    marginYinP = 20; // %
    gutterXinP = 8; // %
    gutterYinP = 14; // %
    columnsNo = 4;
    // layout math
    columnInP = (100 - (marginXinP * 2) - (columnsNo - 1) * gutterXinP) / columnsNo; // 24%
    marginX = Q.width * marginXinP * 0.01;
    gutterX = Q.width * gutterXinP * 0.01;
    columnWidth = Q.width * columnInP * 0.01;
    marginY = Q.height * marginYinP * 0.01;
    gutterY = Q.height * gutterYinP * 0.01;
    rowHeight = Q.height * 0.22; // 22%
    
    // init params
    x = marginX + columnWidth / 2;
    y = marginY + rowHeight / 2;
    w = columnWidth;
    h = rowHeight;
// prepare special buttons for first column

// add level buttons
    for (item = j = 0; j <= 6; item = ++j) {
      if (item % columnsNo === 0) {
        x = marginX + columnWidth / 2;
        if (item > 0) {
          y += rowHeight + gutterY;
        }
      }
      // put button into container
      container = stage.insert(new Q.UI.Container({
        x: x,
        y: y
      }));
      x += columnWidth + gutterX;
      if (item === 0) { // previous button  
        enabled = Game.moreLevelsPage > 0;
        arrow = container.insert(new Q.UI.ArrowButton({
          x: 0,
          y: 0,
          w: w,
          h: h,
          flip: "x",
          page: Game.moreLevelsPage - 1,
          enabled: enabled
        }, fontsize = Styles.fontsize4));
        container.insert(new Q.UI.Text({
          x: 10,
          y: -arrow.p.h / 7,
          label: "Previous",
          color: "#404444",
          family: "Jolly Lodger",
          size: fontsize
        }));
      } else if (item === 3) { // next button
        max_pages = Math.ceil(Game.levels_array.length - 6) / 4;
        enabled = Game.moreLevelsPage + 1 < max_pages;
        arrow = container.insert(new Q.UI.ArrowButton({
          x: 0,
          y: 0,
          w: w,
          h: h,
          page: Game.moreLevelsPage + 1,
          enabled: enabled
        }, fontsize = Styles.fontsize4));
        container.insert(new Q.UI.Text({
          x: -10,
          y: -arrow.p.h / 7,
          label: "Next",
          color: "#404444",
          family: "Jolly Lodger",
          size: fontsize
        }));
      } else if (item === 4) {
        // Pause button bottom left
        pauseButton = container.insert(new Q.UI.PauseButton({
          x: 0,
          y: 0,
          isSmall: false
        }));
      } else {
        // work out level number
        level = item + 5 + Game.moreLevelsPage * 4;
        if (item > 3) {
          level = level - 2;
        }
        if (level < Game.levels_array.length) {
          button = new Q.UI.LevelButton({
            level: level,
            x: 0,
            y: 0,
            w: w,
            h: h,
            enabled: true
          });
          container.insert(button);
          
          // add label if level has name
          // ugh, there's a bit of confusion here with off-by-one indexing
          level_name = Game.levels_array[level].name;
          if (level_name) {
            fontsize = Styles.fontsize3;
            Q.ctx.font = "400 " + fontsize + "px Jolly Lodger";
            name_width = Q.ctx.measureText(level_name).width;
            // background panel
            container.insert(new Q.UI.Container({
              x: 0,
              y: button.p.h * .5 - fontsize * 0.05,
              w: name_width * 1.25,
              h: fontsize * 1.1,
              radius: 2,
              fill: "#81879377",
              type: Q.SPRITE_UI | Q.SPRITE_DEFAULT
            }));
            // foreground text
            container.insert(new Q.UI.Text({
              x: 0,
              y: button.p.h * .5,
              label: level_name,
              color: "#000000",
              family: "Jolly Lodger",
              size: fontsize
            }));
          }
          
          // add progress stars          
          if (item > 0) {
            stars = Game.achievements.progress[level].get();
          }
          if (stars) {
            starsX = -60;
            starsY = [34, 50, 40];
            for (i = l = 1, ref = stars; (1 <= ref ? l <= ref : l >= ref); i = 1 <= ref ? ++l : --l) {
              container.insert(new Q.UI.LevelScoreImgSmall({
                x: starsX,
                y: starsY[i - 1]
              }));
              starsX += 60;
            }
          }
        }
      }
    }
    // end of adding level buttons

    // Back button bottom right
    menuButton = stage.insert(new Q.UI.MenuButton({
      x: x,
      y: y,
      isSmall: false
    }));
    menuButton.on('click', () => {
      return Game.stageLevelSelectScreen();
    });
    // separator bars
    x_sep = marginX + columnWidth + gutterX / 2;
    ref1 = [x_sep, Q.width - x_sep];
    for (m = 0, len = ref1.length; m < len; m++) {
      x = ref1[m];
      stage.insert(new Q.UI.Container({
        x: x,
        y: Q.height / 2,
        w: 10,
        h: Q.height * 0.65,
        fill: "#81879366",
        radius: 8,
        type: Q.SPRITE_UI | Q.SPRITE_DEFAULT
      }));
    }
    // background
    stage.insert(new Q.UI.Container({
      x: Q.width / 2,
      y: Q.height / 2,
      w: x_sep + 5,
      h: Q.height * 0.65,
      fill: "#81879333",
      radius: 8,
      type: Q.SPRITE_UI | Q.SPRITE_DEFAULT
    }));
    // add title
    stage.insert(new Q.UI.Text({
      x: Q.width / 2,
      y: marginY / 2,
      label: "Bonus levels!",
      color: "#f2da38",
      family: "Jolly Lodger",
      size: Styles.fontsize9
    }));
    authors = stage.insert(new Q.UI.Authors());
    cursorButton = stage.insert(new Q.UI.CursorButton({
      y: marginY / 2
    }));
    
    // about button
    aboutButton = stage.insert(new Q.UI.Button({
      y: marginY / 2,
      label: "About",
      fill: "#818793",
      radius: 10,
      fontColor: "#404444",
      font: "400 32px Jolly Lodger",
      z: 100,
      type: Q.SPRITE_UI | Q.SPRITE_DEFAULT
    }));
    aboutButton.on("click", function(e) {
      return Game.stageScreen("about");
    });
    aboutButton.p.x = marginX + aboutButton.p.w / 2;
    cursorButton.p.x = Q.width - marginX - cursorButton.p.w / 2;
    return stage.insert(new Q.UI.CursorWarning);
  });

  Q = Game.Q;

  Q.scene("levelSelect", function(stage) {
    var aboutButton, authors, bonus, columnInP, columnWidth, columnsNo, container, cursorButton, enabled, fontsize, gutterX, gutterXinP, gutterY, gutterYinP, h, i, item, j, l, level, marginX, marginXinP, marginY, marginYinP, ref, rowHeight, settings, settings_label, stars, starsX, starsY, w, x, y;
    // audio
    Q.AudioManager.stopAll();
    Q.AudioManager.clear();
    // layout params
    marginXinP = 20; // %
    marginYinP = 20; // %
    gutterXinP = 8; // %
    gutterYinP = 14; // %
    columnsNo = 4;
    // layout math
    columnInP = (100 - (marginXinP * 2) - (columnsNo - 1) * gutterXinP) / columnsNo; // 24%
    marginX = Q.width * marginXinP * 0.01;
    gutterX = Q.width * gutterXinP * 0.01;
    columnWidth = Q.width * columnInP * 0.01;
    marginY = Q.height * marginYinP * 0.01;
    gutterY = Q.height * gutterYinP * 0.01;
    rowHeight = Q.height * 0.22; // 22%
    
    // init params
    x = marginX + columnWidth / 2;
    y = marginY + rowHeight / 2;
    w = columnWidth;
    h = rowHeight;
// prepare special buttons for first column

// add level buttons
    for (item = j = 0; j <= 6; item = ++j) {
      if (item % columnsNo === 0) {
        x = marginX + columnWidth / 2;
        if (item > 0) {
          y += rowHeight + gutterY;
        }
      }
      enabled = item <= Game.achievements.availableLevel.get() ? true : false;
      // tutorial disabled in keyboard-mode
      if (Game.settings.useKeyboardInstead.get() && item === 0) {
        enabled = false;
      }
      // put button into container
      container = stage.insert(new Q.UI.Container({
        x: x,
        y: y
      }));
      x += columnWidth + gutterX;
      // If we've unlocked levels, we'll replace L6 with a link to "more levels"
      if (item === 6) {
        break;
      }
      container.insert(new Q.UI.LevelButton({
        level: item,
        x: 0,
        y: 0,
        w: w,
        h: h,
        enabled: enabled,
        keyActionName: item === Game.achievements.getNextUncompletedLevel() ? "confirm" : null
      }));
      // Add label for tutorial
      if (item === 0) {
        container.insert(new Q.UI.Text({
          x: 0,
          y: 0,
          label: "Tutorial",
          color: "#404444",
          family: "Jolly Lodger",
          size: Styles.fontsize4
        }));
      }
      // add progress stars
      level = item;
      if (item > 0) {
        stars = Game.achievements.progress[level].get();
      }
      if (stars) {
        starsX = -60;
        starsY = [34, 50, 40];
        for (i = l = 1, ref = stars; (1 <= ref ? l <= ref : l >= ref); i = 1 <= ref ? ++l : --l) {
          container.insert(new Q.UI.LevelScoreImgSmall({
            x: starsX,
            y: starsY[i - 1]
          }));
          starsX += 60;
        }
      }
    }
    // end of adding level buttons

    // "More levels!"  
    bonus = container.insert(new Q.UI.MoreLevelsButton({
      x: 0,
      y: 0,
      w: w,
      h: h
    }));
    fontsize = 32;
    container.insert(new Q.UI.Text({
      x: 0,
      y: -fontsize / 2,
      label: "Extra",
      color: "#404444",
      family: "Jolly Lodger",
      size: fontsize
    }));
    container.insert(new Q.UI.Text({
      x: 0,
      y: fontsize / 2,
      label: "levels",
      color: "#404444",
      family: "Jolly Lodger",
      size: fontsize
    }));
    // settings button bottom right
    container = stage.insert(new Q.UI.Container({
      x: x,
      y: y
    }));
    settings = container.insert(new Q.UI.SettingsButton({
      x: 0,
      y: 0,
      w: w,
      h: h
    }));
    settings_label = container.insert(new Q.UI.Text({
      x: 0,
      y: settings.p.h / 6,
      label: "Settings",
      color: "#404444",
      family: "Jolly Lodger",
      size: Styles.fontsize4
    }));
    container.insert(new Q.Sprite({
      x: 2,
      y: settings_label.p.y - settings_label.p.h - 15,
      sheet: "settings_button"
    }));
    // add title
    stage.insert(new Q.UI.Text({
      x: Q.width / 2,
      y: marginY / 2,
      label: "Everything begins here!",
      color: "#f2da38",
      family: "Jolly Lodger",
      size: Styles.fontsize9
    }));
    authors = stage.insert(new Q.UI.Authors());
    cursorButton = stage.insert(new Q.UI.CursorButton({
      y: marginY / 2
    }));
    stage.insert(new Q.UI.CursorWarning);
    // about button
    aboutButton = stage.insert(new Q.UI.Button({
      y: marginY / 2,
      label: "About",
      fill: "#818793",
      radius: 10,
      fontColor: "#404444",
      font: "400 32px Jolly Lodger",
      z: 100,
      type: Q.SPRITE_UI | Q.SPRITE_DEFAULT
    }));
    aboutButton.on("click", function(e) {
      return Game.stageScreen("about");
    });
    aboutButton.p.x = marginX + aboutButton.p.w / 2;
    return cursorButton.p.x = Q.width - marginX - cursorButton.p.w / 2;
  });

  Q = Game.Q;

  Q.scene("levelSummary", function(stage) {
    var buttonBack, buttonNext, columnInP, columnWidth, columnsNo, currentLevel, empty, gutterX, gutterXinP, index, j, lineHeight, marginX, marginXinP, marginY, msg, nextLevelAvailable, performance, score, scoreImg, stars, starsContainer, summaryContainer, x;
    // some math
    marginY = Q.height * 0.25;
    marginXinP = 20; // %
    gutterXinP = 8; // %
    columnsNo = 2;
    // layout math
    columnInP = (100 - (marginXinP * 2) - (columnsNo - 1) * gutterXinP) / columnsNo; // 24%
    marginX = Q.width * marginXinP * 0.01;
    gutterX = Q.width * gutterXinP * 0.01;
    columnWidth = Q.width * columnInP * 0.01;
    // audio
    Q.AudioManager.stopAll();
    // add title
    stage.insert(new Q.UI.Text({
      x: Q.width / 2,
      y: marginY * .75,
      label: "Well done!",
      color: "#f2da38",
      family: "Jolly Lodger",
      size: Styles.fontsize14
    }));
    // add level summary
    summaryContainer = stage.insert(new Q.UI.Container({
      x: marginX + columnWidth / 2,
      y: Q.height / 2
    }));
    lineHeight = 50;
    if (stage.options.health) {
      summaryContainer.insert(new Q.UI.Text({
        x: 0,
        y: -lineHeight * 2,
        label: "Health collected: " + stage.options.health.collected + "/" + stage.options.health.available,
        color: "#c4da4a",
        family: "Boogaloo",
        size: Styles.fontsize5
      }));
    }
    if (stage.options.zombies) {
      summaryContainer.insert(new Q.UI.Text({
        x: 0,
        y: -lineHeight,
        label: "Zombies healed: " + stage.options.zombies.healed + "/" + stage.options.zombies.available,
        color: "#c4da4a",
        family: "Boogaloo",
        size: Styles.fontsize5
      }));
    }
    if (stage.options.bullets) {
      summaryContainer.insert(new Q.UI.Text({
        x: 0,
        y: 0,
        label: "Bullets wasted: " + stage.options.bullets.waisted + "/" + stage.options.bullets.available,
        color: "#c4da4a",
        family: "Boogaloo",
        size: Styles.fontsize5
      }));
    }
    if (stage.options.zombieModeFound != null) {
      summaryContainer.insert(new Q.UI.Text({
        x: 0,
        y: lineHeight,
        label: "Zombie Mode: " + (stage.options.zombieModeFound ? "done" : "not found"),
        color: "#c4da4a",
        family: "Boogaloo",
        size: Styles.fontsize5
      }));
    }
    // button next
    currentLevel = Q.state.get("currentLevel");
    nextLevelAvailable = currentLevel < 5;
    // (we don't have a 'next' level between main levels and bonuses, need to figure out best
    // flow here...)
    if (nextLevelAvailable) {
      buttonNext = stage.insert(new Q.UI.Button({
        y: Q.height - marginY,
        w: Q.width / 4,
        h: 150,
        fill: "#c4da4a",
        radius: 10,
        fontColor: "#353b47",
        font: "400 58px Jolly Lodger",
        label: "Play next",
        keyActionName: "confirm",
        type: Q.SPRITE_UI | Q.SPRITE_DEFAULT
      }));
      buttonNext.p.x = Q.width / 2 + buttonNext.p.w / 2 + 40;
      buttonNext.on("click", function(e) {
        // last level just finished
        return Game.stageLevel(Q.state.get("currentLevel") + 1);
      });
    }
    
    // button back  
    buttonBack = stage.insert(new Q.UI.Button({
      y: Q.height - marginY,
      w: Q.width / 4,
      h: 150,
      fill: "#f2da38",
      radius: 10,
      fontColor: "#353b47",
      font: "400 58px Jolly Lodger",
      label: "Main menu",
      type: Q.SPRITE_UI | Q.SPRITE_DEFAULT
    }));
    buttonBack.p.x = Q.width / 2 - buttonBack.p.w / 2 - 40;
    buttonBack.on("click", function(e) {
      return Game.stageLevelSelectScreen();
    });
    if (!nextLevelAvailable) {
      buttonBack.p.x = Q.width / 2;
    }
    
    // count stars
    score = stage.options.zombies.healed / stage.options.zombies.available;
    performance = Game.achievements.evaluatePerformance(score);
    stars = performance["stars"];
    msg = performance["message"];
    Game.achievements.update(Q.state.get("currentLevel"), stars);
    // insert stars on the screen
    starsContainer = stage.insert(new Q.UI.Container({
      x: summaryContainer.p.x + gutterX + columnWidth,
      y: Q.height / 2
    }));
    x = -80 - 20; // width of LevelScoreImg - margin between stars
    for (index = j = 1; j <= 3; index = ++j) {
      empty = stars >= index ? false : true;
      scoreImg = starsContainer.insert(new Q.UI.LevelScoreImg({
        x: x,
        y: -lineHeight / 2,
        empty: empty
      }));
      x += scoreImg.p.w + 20;
    }
    // Score:
    stage.insert(new Q.UI.Text({
      x: starsContainer.p.x,
      y: starsContainer.p.y + scoreImg.p.h * 0.6,
      label: "Score: " + msg,
      color: "#ffffff",
      family: "Boogaloo",
      size: Styles.fontsize5
    }));
    // Narrate score
    if (Game.settings.narrationEnabled.get()) {
      responsiveVoice.speak("Well done! Your score is ... " + msg);
    }
    Game.trackEvent("levelSummary:" + Q.state.get("currentLevel"), "score", score);
    Game.trackEvent("levelSummary:" + Q.state.get("currentLevel"), "stars", stars);
    Game.trackEvent("levelSummary:" + Q.state.get("currentLevel"), "Zombie Mode", stage.options.zombieModeFound);
    Game.trackEvent("levelSummary:" + Q.state.get("currentLevel"), "Health collected", stage.options.health.collected + "/" + stage.options.health.available);
    Game.trackEvent("levelSummary:" + Q.state.get("currentLevel"), "Zombies healed", stage.options.zombies.healed + "/" + stage.options.zombies.available);
    return Game.trackEvent("levelSummary:" + Q.state.get("currentLevel"), "Bullets wasted", stage.options.bullets.waisted + "/" + stage.options.bullets.available);
  });

  Q = Game.Q;

  Q.scene("paused", function(stage) {
    var marginBottomButtons, pauseButton;
    stage.insert(new Q.UI.Container({
      x: Q.width / 2,
      y: Q.height / 2,
      w: Q.width,
      h: Q.height,
      z: 50,
      fill: "rgba(0,0,0,0.5)"
    }));
    stage.insert(new Q.UI.Text({
      x: Q.width / 2,
      y: Q.height / 2,
      label: "Paused",
      color: "#f2da38",
      family: "Jolly Lodger",
      size: Styles.fontsize14
    }));
    // Un-pause button 
    // (We can't reuse a pause button from another stage because we want only this one stage
    // to respond to gaze)

    // Bottom buttons
    marginBottomButtons = Q.height * 0.1;
    return pauseButton = stage.insert(new Q.UI.PauseButton({
      x: marginBottomButtons,
      y: Q.height - marginBottomButtons,
      isSmall: false,
      unpause: true
    }));
  });

  Q = Game.Q;

  Q.scene("preview", function(stage) {
    var background, bullets_per_gun, data_asset, objects;
    data_asset = Game.assets.preview.dataAsset;
    bullets_per_gun = 100;
    // main map with collision
    Game.map = Q.LevelParser.load_map(data_asset, Game.SPRITE_TILES, 0);
    stage.collisionLayer(Game.map);
    
    // background decorations
    background = Q.LevelParser.load_map(data_asset, Game.SPRITE_NONE, 1);
    stage.insert(background);
    objects = Q.LevelParser.parse_objects(data_asset, []);
    return Q.LevelParser.load_objects(stage, objects, bullets_per_gun);
  });

  Q = Game.Q;

  Q.scene("restartOptions", function(stage) {
    var buttonBack, buttonHeight, buttonNext, buttonResume, buttonWidth, font;
    // # some math
    // marginY = Q.height * 0.25
    buttonHeight = 80;
    // marginXinP = 20 # %
    // gutterXinP = 8 # %
    // columnsNo = 2

    // # layout math
    // columnInP = (100 - (marginXinP * 2) - (columnsNo - 1) * gutterXinP)/columnsNo  # 24%

    // marginX = Q.width * marginXinP * 0.01
    // gutterX = Q.width * gutterXinP * 0.01
    // columnWidth = Q.width * columnInP * 0.01

    // audio
    Q.AudioManager.stopAll();
    font = "400 48px Jolly Lodger";
    Q.ctx.font = font;
    buttonWidth = 1.1 * Q.ctx.measureText("Back to all levels").width;
    buttonWidth = Math.max(buttonWidth, Q.width / 5);
    buttonHeight = Math.min(Q.height / 3, Q.width / 5);
    
    // button next
    buttonNext = stage.insert(new Q.UI.Button({
      y: Q.height / 2,
      w: buttonWidth,
      h: buttonHeight,
      fill: "#c4da4a",
      radius: 10,
      fontColor: "#353b47",
      font: font,
      label: "Restart level",
      keyActionName: "confirm",
      type: Q.SPRITE_UI | Q.SPRITE_DEFAULT
    }));
    buttonNext.on("click", function(e) {
      return Game.stageLevel(Q.state.get("currentLevel"));
    });
    // button back
    buttonBack = stage.insert(new Q.UI.Button({
      y: Q.height / 2,
      w: buttonWidth,
      h: buttonHeight,
      fill: "#f2da38",
      radius: 10,
      fontColor: "#353b47",
      font: font,
      label: "Back to all levels",
      type: Q.SPRITE_UI | Q.SPRITE_DEFAULT
    }));
    buttonBack.on("click", function(e) {
      return Game.stageLevelSelectScreen();
    });
    // resume
    buttonResume = stage.insert(new Q.UI.Button({
      y: Q.height / 2,
      w: buttonWidth,
      h: buttonHeight,
      fill: "#f2da38",
      radius: 10,
      fontColor: "#353b47",
      font: font,
      label: "Resume game",
      type: Q.SPRITE_UI | Q.SPRITE_DEFAULT
    }));
    buttonResume.on("click", function(e) {
      return console.log('not yet implemented!');
    });
    // layout
    buttonNext.p.x = Q.width * 0.2;
    buttonBack.p.x = Q.width * (1.0 - 0.2);
    return buttonResume.p.x = Q.width / 2;
  });

  Q = Game.Q;

  Q.scene("settingsPlaceholder", function(stage) {
    var authors, button, buttonTextSize, desc, description, label, title, titleContainer, y_pad;
    // add title
    y_pad = Q.height / 20;
    titleContainer = stage.insert(new Q.UI.Container({
      x: Q.width / 2,
      y: Q.height / 2
    }));
    // description = "Imagine, what if the cure exists?\n"
    description = "This will be a settings page\n";
    description += "...including...\n";
    description += "\n";
    description += "- dwell/click settings\n";
    description += "- Sizing of game UI\n";
    description += "- difficulty, including hard-core and god mode \n";
    description += "- more settings for music / sounds / narration\n";
    // TODO link to https://raw.githubusercontent.com/cykod/Quintus/master/MIT-LICENSE.txt
    // probably a link to github where we can more easily detail things / give links
    desc = titleContainer.insert(new Q.UI.Text({
      x: 0,
      y: 0,
      align: 'center',
      label: description,
      color: "#000000",
      family: "Jolly Lodger",
      size: Styles.fontsize5
    }));
    // panel
    titleContainer.insert(new Q.UI.Container({
      x: 0,
      y: 0,
      w: desc.p.w * 1.1,
      h: desc.p.h * 1.1,
      z: desc.p.z - 1,
      fill: "#e3ecf933",
      radius: 8,
      type: Q.SPRITE_UI | Q.SPRITE_DEFAULT
    }));
    title = titleContainer.insert(new Q.UI.Text({
      x: 0,
      y: desc.p.y - desc.p.h / 2,
      label: "Settings",
      color: "#f2da38",
      family: "Jolly Lodger",
      size: Styles.fontsize13
    }));
    title.p.y = title.p.y - title.p.h / 2 - y_pad;
    title.size();
    // button
    label = "Back";
    buttonTextSize = Q.ctx.measureText(label);
    button = titleContainer.insert(new Q.UI.Button({
      x: 0,
      y: desc.p.y + desc.p.h / 2,
      w: buttonTextSize.width * 1.3,
      h: 80,
      fill: "#c4da4a",
      radius: 10,
      fontColor: "#353b47",
      font: "400 58px Jolly Lodger",
      label: label,
      keyActionName: "confirm",
      type: Q.SPRITE_UI | Q.SPRITE_DEFAULT
    }));
    button.p.y = button.p.y + button.p.h / 2 + y_pad * 2;
    titleContainer.fit();
    // authors
    authors = stage.insert(new Q.UI.Authors());
    return button.on("click", function(e) {
      return Game.stageLevelSelectScreen();
    });
  });

  Q = Game.Q;

  Q.scene("start", function(stage) {
    var authors, button, buttonTextSize, desc, desc_fontsize, description, gaze_message, label, marginButtonsY, msg_fontsize, panel, title, titleContainer, y_cursor_warning, y_desc_top, y_pad, y_title_bottom;
    // We only get here if cookies have been accepted; do any setup we need to now. 
    Game.onCookieAcceptance();
    // add title
    y_pad = Q.height / 20;
    titleContainer = stage.insert(new Q.UI.Container({
      x: Q.width / 2,
      y: Q.height / 2
    }));
    marginButtonsY = Q.height / 8;
    // panel
    panel = titleContainer.insert(new Q.UI.Container({
      x: 0,
      y: 0,
      w: 1,
      h: 1,
      fill: "#e3ecf933",
      radius: 8,
      type: Q.SPRITE_UI | Q.SPRITE_DEFAULT
    }));
    // description = "Imagine, what if the cure exists?\n"
    description = "You have found the cure for the zombie plague!\n\n";
    description += "Explore an old, abandoned graveyard,\n";
    description += "heal as many zombies as you can,\n";
    description += "and find your way out.\n\n";
    description += "But be careful not to become one of them!";
    desc_fontsize = Math.max(Styles.fontsize3, Q.height / 20);
    desc = titleContainer.insert(new Q.UI.Text({
      x: 0,
      y: 0,
      align: 'center',
      label: description,
      color: "#2d3032",
      family: "Jolly Lodger",
      size: desc_fontsize
    }));
    // resize panel
    panel.p.w = desc.p.w * 1.1;
    panel.p.h = desc.p.h * 1.1;
    panel.p.x -= panel.p.w / 2;
    panel.p.y -= panel.p.h / 2;
    title = titleContainer.insert(new Q.UI.Text({
      x: 0,
      y: -(Q.height / 2 - marginButtonsY),
      label: "Heal'em All",
      color: "#f2da38",
      family: "Jolly Lodger",
      size: Styles.fontsize11
    }));
    // title.p.y = title.p.y - title.p.h/2 - y_pad
    title.size();
    // button
    label = "Continue";
    buttonTextSize = Q.ctx.measureText(label);
    button = titleContainer.insert(new Q.UI.Button({
      x: 0,
      y: Q.height / 2 - marginButtonsY,
      w: buttonTextSize.width * 1.3,
      h: 80,
      fill: "#c4da4a",
      radius: 10,
      fontColor: "#353b47",
      font: "400 58px Jolly Lodger",
      label: label,
      keyActionName: "confirm",
      type: Q.SPRITE_UI | Q.SPRITE_DEFAULT
    }));
    // Cursor warning if it's been left turned off
    y_title_bottom = title.p.y + title.p.h / 2;
    y_desc_top = desc.p.y - desc.p.h / 2;
    y_cursor_warning = (y_title_bottom + y_desc_top) / 2;
    Q.CompositeUI.add_cursor_warning(titleContainer, 0, y_cursor_warning);
    
    gaze_message = "[This is an eye gaze accessible website, controlled using a cursor or touch]";
    msg_fontsize = Math.min(Styles.fontsize2, Q.height / 30);
    title = titleContainer.insert(new Q.UI.Text({
      x: 0,
      y: button.p.y - button.p.h,
      label: gaze_message,
      color: "#c4da4a",
      family: "Jolly Lodger",
      size: msg_fontsize
    }));
    title.p.y = button.p.y - button.p.h * .5 - title.p.h * 0.5;
    // button.p.y = button.p.y + button.p.h/2 + y_pad*2
    titleContainer.fit();
    // authors
    authors = stage.insert(new Q.UI.Authors());
    return button.on("click", function(e) {
      return Game.stageScreen("start_settings");
    });
  });

  Q = Game.Q;

  Q.scene("start_controls", function(stage) {
    var authors, button, buttonLabelOffset, buttonPosX, buttonPosY, buttonTextSize, gazeButton, gazeText, gray, keyboardButton, keyboardText, label, marginButtonsY, title, titleContainer, y_pad, yellow;
    // add title
    y_pad = Q.height / 20;
    titleContainer = stage.insert(new Q.UI.Container({
      x: Q.width / 2,
      y: Q.height / 2
    }));
    gray = "#818793";
    yellow = "#f2da38";
    buttonPosX = Q.width / 6;
    buttonPosY = 0;
    marginButtonsY = Q.height / 8;
    keyboardButton = titleContainer.insert(new Q.UI.ToggleButton({
      type: Q.SPRITE_UI | Q.SPRITE_DEFAULT,
      x: buttonPosX,
      y: -buttonPosY,
      btn_sheet: "keyboard_controls",
      do_toggle: false
    }));
    gazeButton = titleContainer.insert(new Q.UI.ToggleButton({
      type: Q.SPRITE_UI | Q.SPRITE_DEFAULT,
      x: -buttonPosX,
      y: -buttonPosY,
      btn_sheet: "gaze_touch_etc",
      do_toggle: false
    }));
    buttonLabelOffset = gazeButton.p.h * 0.7;
    titleContainer.insert(new Q.UI.Text({
      x: 0,
      y: gazeButton.p.y - buttonLabelOffset,
      label: "Choose your controls:",
      color: gray,
      family: "Boogaloo",
      size: Styles.fontsize5
    }));
    gazeText = titleContainer.insert(new Q.UI.Text({
      x: gazeButton.p.x,
      y: gazeButton.p.y + buttonLabelOffset,
      label: "Gaze / mouse / touch",
      family: "Boogaloo",
      size: Styles.fontsize5
    }));
    keyboardText = titleContainer.insert(new Q.UI.Text({
      x: keyboardButton.p.x,
      y: gazeButton.p.y + buttonLabelOffset,
      label: "Keyboard",
      family: "Boogaloo",
      size: Styles.fontsize5
    }));
    
    // these toggle buttons are exclusive, and don't click off. 
    keyboardButton.on("click", function(e) {
      keyboardButton.pressed = true;
      keyboardText.p.color = yellow;
      gazeButton.pressed = false;
      return gazeText.p.color = gray;
    });
    gazeButton.on("click", function(e) {
      keyboardButton.pressed = false;
      keyboardText.p.color = gray;
      gazeButton.pressed = true;
      return gazeText.p.color = yellow;
    });
    gazeButton.pressed = true;
    keyboardText.p.color = gray;
    gazeText.p.color = yellow;
    
    // cursorLabel = titleContainer.insert new Q.UI.Text
    //   y: buttonPosY
    //   label: "Show cursor?"
    //   color: "#818793"
    //   family: "Boogaloo"
    //   size: Styles.fontsize5

    // label_pad = gazeButton.p.w/4
    // cursorLabel.p.x = gazeButton.p.x - gazeButton.p.w/2 - cursorLabel.p.w/2 - label_pad
    // audioLabel.p.x = keyboardButton.p.x - keyboardButton.p.w/2 - audioLabel.p.w/2 - label_pad
    title = titleContainer.insert(new Q.UI.Text({
      x: 0,
      y: -(Q.height / 2 - marginButtonsY),
      label: "Heal'em All",
      color: yellow,
      family: "Jolly Lodger",
      size: Styles.fontsize13
    }));
    // button
    label = "Continue";
    buttonTextSize = Q.ctx.measureText(label);
    button = titleContainer.insert(new Q.UI.Button({
      x: 0,
      y: Q.height / 2 - marginButtonsY,
      w: buttonTextSize.width * 1.3,
      h: 80,
      fill: "#c4da4a",
      radius: 10,
      fontColor: "#353b47",
      font: "400 58px Jolly Lodger",
      label: label,
      keyActionName: "confirm",
      type: Q.SPRITE_UI | Q.SPRITE_DEFAULT
    }));
    titleContainer.fit();
    // authors
    authors = stage.insert(new Q.UI.Authors());
    stage.insert(new Q.UI.CursorWarning);
    return button.on("click", function(e) {
      // Save the controls
      if (gazeButton.pressed) {
        console.log('Using gaze!');
        Game.settings.useKeyboardInstead.set(false);
        return Game.stageScreen("start_settings");
      } else if (keyboardButton.pressed) {
        console.log('Using keyboard!');
        Game.settings.useKeyboardInstead.set(true);
        Game.stageLevelSelectScreen();
        return Game.turnOffGaze();
      }
    });
  });

  Q = Game.Q;

  Q.scene("tutorial", function(stage) {
    var background, bullets_per_gun, clone, combined_label, combined_prop, component, data_asset, enemies, helptext, ignore_objects, j, l, len, len1, objects, text_props, texts, typeIsArray, xFudge, yFudge;
    data_asset = Game.assets.tutorial.dataAsset;
    bullets_per_gun = 20;
    // main map with collision
    Game.map = Q.LevelParser.load_map(data_asset, Game.SPRITE_TILES, 0);
    stage.collisionLayer(Game.map);
    
    // background decorations
    background = Q.LevelParser.load_map(data_asset, Game.SPRITE_NONE, 1);
    stage.insert(background);
    // all other objects, except zombie, which will be special for tutorial
    ignore_objects = ["Zombie"];
    objects = Q.LevelParser.parse_objects(data_asset, ignore_objects);
    Q.LevelParser.load_objects(stage, objects, bullets_per_gun);
    // overall adjustments
    yFudge = 1.75;
    xFudge = 10;
    // Add zombie manually
    enemies = [
      [
        "Zombie",
        Q.tilePos(xFudge + 72,
        14,
        {
          canFallOff: false
        })
      ]
    ];
    stage.loadAssets(enemies);
    // store level data for level summary
    Game.currentLevelData.health.available = stage.lists.Heart.length;
    Game.currentLevelData.zombies.available = stage.lists.Zombie.length;
    // Add help texts
    texts = [
      Q.tilePos(xFudge + 38,
      8 + yFudge,
      {
        label: "Look at the left and right arrows below to walk"
      }),
      Q.tilePos(xFudge + 46,
      11 + yFudge,
      {
        label: "The longer you look, the faster you'll walk"
      }),
      Q.tilePos(xFudge + 54,
      11 + yFudge,
      {
        label: "Dwell on a jump button to jump sideways"
      }),
      Q.tilePos(xFudge + 64.5,
      9 + yFudge,
      {
        label: "Try jumping over the gap"
      }),
      Q.tilePos(xFudge + 73 - 1.5,
      9 + yFudge,
      {
        label: "Watch out for zombies!"
      }),
      Q.tilePos(xFudge + 77,
      11 + yFudge,
      {
        label: "Try to get past without being bitten"
      }),
      [
        Q.tilePos(xFudge + 83,
        10.5 + yFudge,
        {
          label: "Collect the healing gun,"
        }),
        Q.tilePos(xFudge + 83,
        11 + yFudge,
        {
          label: "and fire at the zombie"
        })
      ],
      Q.tilePos(xFudge + 88,
      9 + yFudge,
      {
        label: "Health packs give you an extra life -->"
      }),
      [
        Q.tilePos(xFudge + 92,
        13 + yFudge,
        {
          label: "To complete the level,"
        }),
        Q.tilePos(xFudge + 92,
        13.5 + yFudge,
        {
          label: "find the key and exit"
        })
      ]
    ];
    typeIsArray = function(value) {
      return value && typeof value === 'object' && value instanceof Array && typeof value.length === 'number' && typeof value.splice === 'function' && !(value.propertyIsEnumerable('length'));
    };
    clone = function(obj) {
      var key, newInstance;
      if ((obj == null) || typeof obj !== 'object') {
        return obj;
      }
      newInstance = new obj.constructor();
      for (key in obj) {
        newInstance[key] = clone(obj[key]);
      }
      return newInstance;
    };
    for (j = 0, len = texts.length; j < len; j++) {
      text_props = texts[j];
      // If we split text over multiple lines (to get nice centering)
      // we need to re-combine for narration.
      if (typeIsArray(text_props)) {
        combined_label = "";
        for (l = 0, len1 = text_props.length; l < len1; l++) {
          component = text_props[l];
          stage.insert(new Q.UI.HelpText(clone(component)));
          combined_label += " " + component.label;
        }
        combined_prop = text_props.pop();
        combined_prop.label = combined_label;
        helptext = [["InfoPoint", combined_prop]];
      } else {
        stage.insert(new Q.UI.HelpText(text_props));
        helptext = [["InfoPoint", text_props]];
      }
      stage.loadAssets(helptext);
    }
    
    // # store level data for level summary
    Game.currentLevelData.health.available = stage.lists.Heart.length;
    return Game.currentLevelData.zombies.available = stage.lists.Zombie.length;
  });

  Q = Game.Q;

  Q.scene("tutorialSummary", function(stage) {
    var buttonBack, buttonHeight, buttonNext, buttonStart, columnInP, columnWidth, columnsNo, gutterX, gutterXinP, level, marginX, marginXinP, marginY, msg, msgLabel, previousStars, score, stars, title;
    // some math
    marginY = Q.height * 0.25;
    buttonHeight = 80;
    marginXinP = 20; // %
    gutterXinP = 8; // %
    columnsNo = 2;
    // layout math
    columnInP = (100 - (marginXinP * 2) - (columnsNo - 1) * gutterXinP) / columnsNo; // 24%
    marginX = Q.width * marginXinP * 0.01;
    gutterX = Q.width * gutterXinP * 0.01;
    columnWidth = Q.width * columnInP * 0.01;
    // audio
    Q.AudioManager.stopAll();
    // add title
    title = stage.insert(new Q.UI.Text({
      x: Q.width / 2,
      y: marginY / 2,
      label: "Well done!",
      color: "#f2da38",
      family: "Jolly Lodger",
      size: Styles.fontsize14
    }));
    msgLabel = "You have successfully completed the tutorial\n";
    msgLabel += "Are you feeling ready to play for real?";
    // message
    msg = stage.insert(new Q.UI.Text({
      x: Q.width / 2,
      y: Q.height / 4 + marginY / 4,
      label: msgLabel,
      color: "#c4da4a",
      family: "Boogaloo",
      size: Styles.fontsize5,
      align: "center"
    }));
    // start main game:
    buttonStart = stage.insert(new Q.UI.Button({
      x: Q.width / 2,
      y: Q.height / 2,
      w: Q.width / 4,
      h: buttonHeight,
      fill: "#c4da4a",
      radius: 10,
      fontColor: "#353b47",
      font: "400 58px Jolly Lodger",
      label: "Start game",
      keyActionName: "confirm",
      type: Q.SPRITE_UI | Q.SPRITE_DEFAULT
    }));
    buttonStart.on("click", function(e) {
      return Game.stageScreen("controls");
    });
    // button next
    buttonNext = stage.insert(new Q.UI.Button({
      y: Q.height - marginY,
      w: Q.width / 4,
      h: buttonHeight,
      fill: "#c4da4a",
      radius: 10,
      fontColor: "#353b47",
      font: "400 58px Jolly Lodger",
      label: "Try again",
      type: Q.SPRITE_UI | Q.SPRITE_DEFAULT
    }));
    buttonNext.p.x = Q.width / 2 + buttonNext.p.w / 2 + 40;
    buttonNext.on("click", function(e) {
      return Game.stageTutorial();
    });
    // button back
    buttonBack = stage.insert(new Q.UI.Button({
      y: Q.height - marginY,
      w: Q.width / 4,
      h: buttonHeight,
      fill: "#f2da38",
      radius: 10,
      fontColor: "#353b47",
      font: "400 58px Jolly Lodger",
      label: "Main menu",
      type: Q.SPRITE_UI | Q.SPRITE_DEFAULT
    }));
    buttonBack.p.x = Q.width / 2 - buttonBack.p.w / 2 - 40;
    buttonBack.on("click", function(e) {
      return Game.stageLevelSelectScreen();
    });
    // save progress in game
    if (Q.state.get("currentLevel") >= Game.achievements.availableLevel.get()) {
      Game.achievements.availableLevel.set(Q.state.get("currentLevel") + 1);
    }
    // count stars
    score = stage.options.zombies.healed / stage.options.zombies.available;
    stars = 0;
    if (score <= 0.5) {
      stars = 1;
    } else if (score > 0.5 && score < 0.9) {
      stars = 2;
    } else {
      stars = 3;
    }
    // save only if better than previous
    level = Q.state.get("currentLevel");
    previousStars = Game.achievements.progress[level].get();
    if (previousStars < stars) {
      Game.achievements.progress[level].set(stars);
    }
    
    // track events
    Game.trackEvent("levelSummary:" + Q.state.get("currentLevel"), "score", score);
    Game.trackEvent("levelSummary:" + Q.state.get("currentLevel"), "stars", stars);
    Game.trackEvent("levelSummary:" + Q.state.get("currentLevel"), "Zombie Mode", stage.options.zombieModeFound);
    Game.trackEvent("levelSummary:" + Q.state.get("currentLevel"), "Health collected", stage.options.health.collected + "/" + stage.options.health.available);
    Game.trackEvent("levelSummary:" + Q.state.get("currentLevel"), "Zombies healed", stage.options.zombies.healed + "/" + stage.options.zombies.available);
    return Game.trackEvent("levelSummary:" + Q.state.get("currentLevel"), "Bullets wasted", stage.options.bullets.waisted + "/" + stage.options.bullets.available);
  });

  Q = Game.Q;

  Q.scene("controls_settings", function(stage) {
    var btn1, btn2, buttonBar, click_layout, cursorButton, cursorLabel, cursor_layout, delta, dwell_getter, dwell_layout, dwell_setter, input_layout, label, label_pad, mainSection, opacity_getter, opacity_layout, opacity_setter, previewButton, preview_layout, scale_getter, scale_layout, scale_setter, titleBar;
    // settings page structure
    [titleBar, mainSection, buttonBar] = Q.CompositeUI.setup_settings_page(stage, "Controls");
    // preview button
    preview_layout = stage.insert(buttonBar.subplot(1, 2, 0, 0));
    label = "Try out\ncontrols";
    previewButton = preview_layout.insert(new Q.UI.Button({
      h: 80,
      fill: "#c4da4a",
      radius: 10,
      fontColor: "#353b47",
      font: "400 32px Jolly Lodger",
      label: label,
      type: Q.SPRITE_UI | Q.SPRITE_DEFAULT
    }));
    previewButton.on("click", function(e) {
      return Game.stagePreview();
    });
    // cursor    
    cursor_layout = stage.insert(mainSection.subplot(3, 2, 0, 1, 0.1));
    cursorButton = cursor_layout.insert(new Q.UI.CursorButton({
      isSmall: false
    }));
    cursorLabel = cursor_layout.insert(new Q.UI.Text({
      label: "Show cursor?",
      color: "#818793",
      family: "Boogaloo",
      size: Styles.fontsize5,
      align: "center"
    }));
    label_pad = cursorButton.p.w / 4;
    delta = cursorButton.p.w / 2 + cursorLabel.p.w / 2 + label_pad;
    cursorLabel.p.x -= delta / 2;
    cursorButton.p.x = cursorButton.p.x + delta / 2;
    Q.CompositeUI.add_cursor_warning(cursor_layout, -delta / 2, cursorLabel.p.h);
    
    // Various adjusters
    dwell_getter = function() {
      var dTimeMs;
      dTimeMs = Number.parseFloat(Game.settings.dwellTime.get());
      return dTimeMs / 1000;
    };
    dwell_setter = function(val) {
      val = val * 1000;
      Game.setupGaze(val);
      return Game.settings.dwellTime.set(val);
    };
    scale_getter = function() {
      return Number.parseFloat(Game.settings.uiScale.get());
    };
    scale_setter = function(val) {
      return Game.settings.uiScale.set(val);
    };
    opacity_getter = function() {
      return Number.parseFloat(Game.settings.uiOpacity.get());
    };
    opacity_setter = function(val) {
      return Game.settings.uiOpacity.set(val);
    };
    input_layout = stage.insert(mainSection.subplot(3, 2, 0, 0, 0.1));
    scale_layout = stage.insert(mainSection.subplot(3, 2, 1, 0, 0.1));
    dwell_layout = stage.insert(mainSection.subplot(3, 2, 2, 1, 0.1));
    opacity_layout = stage.insert(mainSection.subplot(3, 2, 2, 0, 0.1));
    click_layout = stage.insert(mainSection.subplot(3, 2, 1, 1, 0.1));
    Q.CompositeUI.add_adjuster(dwell_layout, 'Dwell time (s)', dwell_getter, dwell_setter, 0.1, 0.1, 3.0);
    Q.CompositeUI.add_adjuster(scale_layout, 'Size of gaze controls', scale_getter, scale_setter, 0.1, 0.2, 2.5);
    Q.CompositeUI.add_adjuster(opacity_layout, 'Opacity of gaze controls', opacity_getter, opacity_setter, 0.05, 0.05, 0.95);
    btn1 = {
      label: "Gaze/mouse/touch",
      sheet: "gaze_touch_etc",
      init_state: !Game.settings.useKeyboardInstead.get(),
      on_click: function(is_initialising) {
        if (!is_initialising) {
          Game.settings.useKeyboardInstead.set(false);
          Game.setupGaze(Game.settings.dwellTime.get());
        }
        scale_layout.p.hidden = false;
        opacity_layout.p.hidden = false;
        dwell_layout.p.hidden = Game.settings.useOwnClickInstead.get();
        click_layout.p.hidden = false;
        previewButton.p.hidden = false;
        return cursor_layout.p.hidden = false;
      }
    };
    btn2 = {
      label: "Keyboard",
      sheet: "keyboard_controls",
      init_state: Game.settings.useKeyboardInstead.get(),
      doDwell: false,
      on_click: function(is_initialising) {
        if (!is_initialising) {
          Game.settings.useKeyboardInstead.set(true);
          Game.turnOffGaze();
        }
        scale_layout.p.hidden = true;
        opacity_layout.p.hidden = true;
        dwell_layout.p.hidden = true;
        click_layout.p.hidden = true;
        previewButton.p.hidden = true;
        return cursor_layout.p.hidden = true;
      }
    };
    Q.CompositeUI.add_exclusive_toggle_buttons(input_layout, btn1, btn2, "Input\nmethod");
    btn1 = {
      label: "Built in dwell",
      sheet: "dwell_click",
      init_state: !Game.settings.useOwnClickInstead.get(),
      on_click: function(is_initialising) {
        if (!is_initialising) {
          Game.settings.useOwnClickInstead.set(false);
          Game.setupGaze(Game.settings.dwellTime.get());
        }
        return dwell_layout.p.hidden = false;
      }
    };
    btn2 = {
      label: "Own click",
      sheet: "own_click",
      init_state: Game.settings.useOwnClickInstead.get(),
      doDwell: false,
      on_click: function(is_initialising) {
        if (!is_initialising) {
          Game.settings.useOwnClickInstead.set(true);
          Game.setupGaze(0); // this turns off dwelling
        }
        return dwell_layout.p.hidden = true;
      }
    };
    return Q.CompositeUI.add_exclusive_toggle_buttons(click_layout, btn1, btn2, "Click\nmethod");
  });

  Q = Game.Q;

  Q.scene("game_settings", function(stage) {
    var ammo_layout, btn, buttonBar, callback, chase_layout, chkAmmo, chkChase, chkGun, fontsize, getter, gun_layout, i, j, layout, lives_layout, mainSection, n_presets, padding, panel, preset_label, preset_label_layout, presets, presets_layout, ref, results, setter, speed_layout, titleBar, update_all, update_lives, update_zombieSpeed;
    // settings page structure
    [titleBar, mainSection, buttonBar] = Q.CompositeUI.setup_settings_page(stage, "Gameplay");
    
    // layouts
    padding = 0.1;
    presets_layout = stage.insert(mainSection.subplot(3, 1, 0, 0, padding));
    lives_layout = stage.insert(mainSection.subplot(3, 2, 1, 0, padding));
    speed_layout = stage.insert(mainSection.subplot(3, 2, 2, 0, padding));
    chase_layout = stage.insert(mainSection.subplot(3, 4, 1, 2, padding));
    gun_layout = stage.insert(mainSection.subplot(3, 4, 1, 3, padding));
    ammo_layout = stage.insert(mainSection.subplot(3, 4, 2, 2, padding));
    // Lives
    getter = function() {
      return Number.parseInt(Game.settings.lives.get());
    };
    setter = function(val) {
      // jump in bigger increments at higher numbers    
      if (val === 11) {
        return Game.settings.lives.set(20);
      } else if (val === 19) {
        return Game.settings.lives.set(10);
      } else if (val === 21) {
        return Game.settings.lives.set(50);
      } else if (val === 49) {
        return Game.settings.lives.set(20);
      } else if (val === 51) {
        return Game.settings.lives.set(100);
      } else if (val === 99) {
        return Game.settings.lives.set(50);
      } else {
        return Game.settings.lives.set(val);
      }
    };
    update_lives = Q.CompositeUI.add_adjuster(lives_layout, 'Spare lives', getter, setter, 1, 0, 100);
    // Zombie speed
    getter = function() {
      return Number.parseFloat(Game.settings.zombieSpeed.get());
    };
    setter = function(val) {
      return Game.settings.zombieSpeed.set(val);
    };
    update_zombieSpeed = Q.CompositeUI.add_adjuster(speed_layout, 'Zombie speed', getter, setter, 0.05, 0.1, 1.5);
    // Other options
    chkChase = Q.CompositeUI.add_checkbox(chase_layout, "Zombies\nchase you", function(checked) {
      return Game.settings.zombiesChase.set(checked);
    });
    chkGun = Q.CompositeUI.add_checkbox(gun_layout, "Start with\ngun", function(checked) {
      return Game.settings.startWithGun.set(checked);
    });
    chkAmmo = Q.CompositeUI.add_checkbox(ammo_layout, "Unlimited\nammo", function(checked) {
      return Game.settings.unlimitedAmmo.set(checked);
    });
    
    // Presets, need to update all the other settings
    update_all = function() {
      chkChase.checked = Game.settings.zombiesChase.get();
      chkGun.checked = Game.settings.startWithGun.get();
      chkAmmo.checked = Game.settings.unlimitedAmmo.get();
      update_lives(Game.settings.lives.get());
      return update_zombieSpeed(Game.settings.zombieSpeed.get());
    };
    // Make sure we start reflecting correct state
    update_all();
    
    // Background panel to hold elements together visually    
    panel = presets_layout.insert(new Q.UI.Container({
      fill: "#e3ecf933",
      radius: 12,
      w: presets_layout.p.w,
      h: presets_layout.p.h
    }));
    // type: Q.SPRITE_UI | Q.SPRITE_DEFAULT
    presets = Game.presets;
    n_presets = presets.length;
    preset_label_layout = stage.insert(presets_layout.subplot(1, n_presets + 1, 0, 0));
    preset_label = preset_label_layout.insert(new Q.UI.Text({
      label: "Presets:",
      color: "#363738",
      family: "Boogaloo",
      size: Styles.fontsize5
    }));
    results = [];
    for (i = j = 0, ref = n_presets - 1; (0 <= ref ? j <= ref : j >= ref); i = 0 <= ref ? ++j : --j) {
      // for label in preset_names
      layout = stage.insert(presets_layout.subplot(1, n_presets + 1, 0, i + 1));
      fontsize = Math.floor(layout.p.h / 3);
      btn = layout.insert(new Q.UI.Button({
        type: Q.SPRITE_UI | Q.SPRITE_DEFAULT,
        label: presets[i].name,
        fontColor: "black",
        font: "400 58px Jolly Lodger",
        h: layout.p.h * .75,
        fill: "#c4da4a",
        radius: 10,
        fontColor: "#353b47",
        font: "400 " + fontsize + "px Jolly Lodger",
        type: Q.SPRITE_UI | Q.SPRITE_DEFAULT
      }));
      callback = function(i) {
        return function() {
          Game.settings.lives.set(presets[i].lives);
          Game.settings.zombieSpeed.set(presets[i].zombieSpeed);
          Game.settings.zombiesChase.set(presets[i].zombiesChase);
          Game.settings.unlimitedAmmo.set(presets[i].unlimitedAmmo);
          Game.settings.startWithGun.set(presets[i].startWithGun);
          return update_all();
        };
      };
      results.push(btn.on("click", callback(i)));
    }
    return results;
  });

  Q = Game.Q;

  Q.scene("settings_menu", function(stage) {
    var add_button, button, buttonBar, button_width, controls_layout, controls_text, fontsize, game_layout, gameplay_text, mainSection, padding, reset_layout, reset_text, sound_layout, sounds_text, textsize, titleBar;
    // settings page structure
    [titleBar, mainSection, buttonBar] = Q.CompositeUI.setup_settings_page(stage, "Settings");
    padding = 0.1;
    controls_layout = stage.insert(mainSection.subplot(2, 2, 0, 0, padding));
    game_layout = stage.insert(mainSection.subplot(2, 2, 0, 1, padding));
    sound_layout = stage.insert(mainSection.subplot(2, 2, 1, 0, padding));
    reset_layout = stage.insert(mainSection.subplot(2, 2, 1, 1, padding));
    controls_text = "Controls";
    gameplay_text = "Gameplay";
    sounds_text = "Sounds";
    textsize = Q.ctx.measureText(gameplay_text);
    button_width = textsize.width;
    add_button = function(layout, label, page) {
      var button, buttonTextSize, fontsize;
      buttonTextSize = Q.ctx.measureText(label);
      fontsize = Math.floor(layout.p.h / 3);
      button = layout.insert(new Q.UI.Button({
        w: button_width * 1.3,
        h: layout.p.h * .75,
        fill: "#c4da4a",
        radius: 10,
        fontColor: "#353b47",
        font: "400 " + fontsize + "px Jolly Lodger",
        label: label,
        type: Q.SPRITE_UI | Q.SPRITE_DEFAULT
      }));
      return button.on("click", (e) => {
        console.log(page);
        return Game.stageScreen(page);
      });
    };
    
    // These buttons share setup code
    add_button(controls_layout, controls_text, "controls_settings");
    add_button(game_layout, gameplay_text, "game_settings");
    add_button(sound_layout, sounds_text, "sound_settings");
    // Reset button is special case
    fontsize = Math.floor(reset_layout.p.h / 5);
    Q.ctx.font = "400 " + fontsize + "px Jolly Lodger";
    reset_text = "Reset all";
    textsize = Q.ctx.measureText(reset_text);
    button_width = textsize.width;
    button = reset_layout.insert(new Q.UI.Button({
      w: button_width * 1.3,
      h: reset_layout.p.h * .25,
      fill: "#c4da4a",
      radius: 10,
      fontColor: "#353b47",
      font: "400 " + fontsize + "px Jolly Lodger",
      label: reset_text,
      type: Q.SPRITE_UI | Q.SPRITE_DEFAULT
    }));
    return button.on("click", (e) => {
      console.log("Reset!!");
      return Game.stageScreen("confirm_reset");
    });
  });

  Q = Game.Q;

  Q.scene("sound_settings", function(stage) {
    var btn1, btn2, buttonBar, chk_music, chk_narration, chk_sfx, error_text, fx_layout, leftmost_x, mainSection, music_callback, music_layout, narrate_callback, narration_error_layout, narration_layout, padding, soundfx_callback, titleBar, voice_layout;
    // settings page structure
    [titleBar, mainSection, buttonBar] = Q.CompositeUI.setup_settings_page(stage, "Sounds");
    // layouts
    padding = 0.1;
    music_layout = stage.insert(mainSection.subplot(2, 2, 0, 0, padding));
    fx_layout = stage.insert(mainSection.subplot(2, 2, 1, 0, padding));
    narration_layout = stage.insert(mainSection.subplot(2, 2, 0, 1, padding));
    narration_error_layout = stage.insert(mainSection.subplot(1, 2, 0, 1, padding));
    voice_layout = stage.insert(mainSection.subplot(2, 2, 1, 1, padding));
    // Callbacks
    music_callback = function(is_pressed) {
      return Game.settings.musicEnabled.set(is_pressed);
    };
    soundfx_callback = function(is_pressed) {
      return Game.settings.soundFxEnabled.set(is_pressed);
    };
    narrate_callback = function(is_pressed) {
      Game.settings.narrationEnabled.set(is_pressed);
      voice_layout.p.hidden = !is_pressed || !responsiveVoice.voiceSupport();
      return error_text.p.hidden = !is_pressed || responsiveVoice.voiceSupport();
    };
    // Checkboxes
    chk_music = Q.CompositeUI.add_checkbox(music_layout, "Music", music_callback);
    chk_sfx = Q.CompositeUI.add_checkbox(fx_layout, "Sound effects", soundfx_callback);
    chk_narration = Q.CompositeUI.add_checkbox(narration_layout, "Game narration", narrate_callback);
    // Initial checkbox state
    chk_music.checked = Game.settings.musicEnabled.get();
    chk_sfx.checked = Game.settings.soundFxEnabled.get();
    chk_narration.checked = Game.settings.narrationEnabled.get();
    // Align all check boxes
    leftmost_x = 0;
    leftmost_x = Math.min(leftmost_x, chk_music.p.x);
    leftmost_x = Math.min(leftmost_x, chk_sfx.p.x);
    leftmost_x = Math.min(leftmost_x, chk_narration.p.x);
    chk_music.p.x = leftmost_x;
    chk_sfx.p.x = leftmost_x;
    chk_narration.p.x = leftmost_x;
    error_text = narration_error_layout.insert(new Q.UI.Text({
      label: "There was an error loading responsiveVoice; narration will not work.",
      color: "#D64E31",
      family: "Boogaloo",
      size: Styles.fontsize2
    }));
    // Narration voice
    btn1 = {
      label: "Male",
      init_state: Game.settings.narrationVoice.get().indexOf("Female") < 0,
      on_click: function(is_initialising) {
        if (!is_initialising) {
          Game.settings.narrationVoice.set("UK English Male");
          responsiveVoice.setDefaultVoice(Game.settings.narrationVoice.get());
          return responsiveVoice.speak("Using male voice");
        }
      }
    };
    btn2 = {
      label: "Female",
      init_state: Game.settings.narrationVoice.get().indexOf("Female") > 0,
      on_click: function(is_initialising) {
        if (!is_initialising) {
          Game.settings.narrationVoice.set("UK English Female");
          responsiveVoice.setDefaultVoice(Game.settings.narrationVoice.get());
          return responsiveVoice.speak("Using female voice");
        }
      }
    };
    Q.CompositeUI.add_exclusive_toggle_buttons(voice_layout, btn1, btn2, "Narrator\nvoice");
    voice_layout.p.hidden = !Game.settings.narrationEnabled.get() || !responsiveVoice.voiceSupport();
    return error_text.p.hidden = !Game.settings.narrationEnabled.get() || responsiveVoice.voiceSupport();
  });

  Q = Game.Q;

  Q.scene("start_settings", function(stage) {
    var audioButton, audioLabel, audio_layout, authors, button, buttonPosX, buttonPosY, buttonTextSize, cachedMusicEnabled, cachedSfxEnabled, cursorButton, cursorLabel, cursor_layout, delta, desc, description, info_layout, label, label_pad, marginButtonsY, padding, panel, title, titleContainer, y_pad;
    // add title
    y_pad = Q.height / 20;
    titleContainer = stage.insert(new Q.UI.Container({
      x: Q.width / 2,
      y: Q.height / 2,
      w: Q.width,
      h: Q.height
    }));
    buttonPosX = Q.width / 12;
    buttonPosY = Q.height / 8;
    marginButtonsY = Q.height / 8;
    padding = 0.1;
    cursor_layout = stage.insert(titleContainer.subplot(4, 2, 1, 0, padding));
    audio_layout = stage.insert(titleContainer.subplot(4, 2, 2, 0, padding));
    info_layout = stage.insert(titleContainer.subplot_multiple(4, 2, 1, 1, 2, 1, padding));
    
    // Sound
    audioButton = audio_layout.insert(new Q.UI.AudioButton({
      isSmall: false
    }));
    cursorButton = cursor_layout.insert(new Q.UI.CursorButton({
      isSmall: false
    }));
    audioLabel = audio_layout.insert(new Q.UI.Text({
      label: "Play sounds/music?",
      color: "#818793",
      family: "Boogaloo",
      size: Styles.fontsize5
    }));
    cachedMusicEnabled = Game.settings.musicEnabled.get();
    cachedSfxEnabled = Game.settings.soundFxEnabled.get();
    if (!cachedSfxEnabled && !cachedMusicEnabled) {
      audioButton.setMuted(true);
      // clicking button will turn on both
      cachedMusicEnabled = true;
      cachedSfxEnabled = true;
    }
    audioButton.on('click', () => {
      audioButton.setMuted(!audioButton.p.isMuted);
      if (audioButton.p.isMuted) {
        Game.settings.musicEnabled.set(false);
        return Game.settings.soundFxEnabled.set(false);
      } else {
        Game.settings.musicEnabled.set(cachedMusicEnabled);
        return Game.settings.soundFxEnabled.set(cachedSfxEnabled);
      }
    });
    cursorLabel = cursor_layout.insert(new Q.UI.Text({
      label: "Show cursor?",
      color: "#818793",
      family: "Boogaloo",
      size: Styles.fontsize5
    }));
    // Adjusting things to align
    delta = audioLabel.p.w / 2 + audioButton.p.w / 2;
    label_pad = cursorButton.p.w / 4;
    delta += label_pad / 2;
    cursorLabel.p.x -= delta / 2;
    audioLabel.p.x -= delta / 2;
    cursorButton.p.x += delta / 2;
    audioButton.p.x += delta / 2;
    Q.CompositeUI.add_cursor_warning(cursor_layout, -delta / 2, cursorLabel.p.h);
    title = titleContainer.insert(new Q.UI.Text({
      x: 0,
      y: -(Q.height / 2 - marginButtonsY),
      label: "Options",
      color: "#f2da38",
      family: "Jolly Lodger",
      size: Styles.fontsize11
    }));
    // button
    label = "Continue";
    buttonTextSize = Q.ctx.measureText(label);
    button = titleContainer.insert(new Q.UI.Button({
      x: 0,
      y: Q.height / 2 - marginButtonsY,
      w: buttonTextSize.width * 1.3,
      h: 80,
      fill: "#c4da4a",
      radius: 10,
      fontColor: "#353b47",
      font: "400 58px Jolly Lodger",
      label: label,
      keyActionName: "confirm",
      type: Q.SPRITE_UI | Q.SPRITE_DEFAULT
    }));
    titleContainer.fit();
    // authors
    authors = stage.insert(new Q.UI.Authors());
    // Separator bar
    stage.insert(new Q.UI.Container({
      x: Q.width / 2,
      y: Q.height / 2,
      w: 10,
      h: Q.height * 0.5,
      fill: "#81879366",
      radius: 8,
      type: Q.SPRITE_UI | Q.SPRITE_DEFAULT
    }));
    // More settings available...

    // panel
    panel = info_layout.insert(new Q.UI.Container({
      x: 0,
      y: 0,
      w: 1,
      h: 1,
      fill: "#e3ecf933",
      radius: 8,
      type: Q.SPRITE_UI | Q.SPRITE_DEFAULT
    }));
    description = "More options available in the \nSettings page, including:\n";
    description += "\n";
    description += "- dwell/click settings\n";
    description += "- sizing of gaze controls\n";
    description += "- game difficulty\n";
    description += "- narration\n";
    desc = info_layout.insert(new Q.UI.Text({
      x: 0,
      y: 0,
      align: 'center',
      label: description,
      color: "#2d3032",
      family: "Jolly Lodger",
      size: Styles.fontsize5
    }));
    // resize panel
    panel.p.w = desc.p.w * 1.1;
    panel.p.h = desc.p.h * 1.1;
    panel.p.x -= panel.p.w / 2;
    panel.p.y -= panel.p.h / 2;
    return button.on("click", function(e) {
      return Game.stageLevelSelectScreen();
    });
  });

  Q = Game.Q;

  Q.Sprite.extend('Background', {
    init: function(p) {
      var ratio;
      this._super(p, {
        x: 0,
        y: 0,
        z: 0,
        asset: Game.assets.map.bg,
        type: Q.SPRITE_NONE
      });
      this.imgEl = this.asset();
      ratio = this.imgEl.width / this.imgEl.height;
      // background cover vertically
      this.imgEl.width = Q.width + 10;
      this.imgEl.height = this.imgEl.width * ratio;
      // find background draw start point to achive viewport.centerX == imgEl.centerX
      this.p.deltaX = (this.imgEl.width - Q.width) / 2;
      return this.p.deltaY = (this.imgEl.height - Q.height) / 2;
    },
    draw: function(ctx) {
      var offsetX, offsetY, viewport;
      viewport = this.stage.viewport;
      if (viewport) {
        offsetX = viewport.centerX - Q.width / 2;
        offsetY = viewport.centerY - Q.height / 2;
      } else {
        offsetX = 0;
        offsetY = 0;
      }
      return ctx.drawImage(this.imgEl, offsetX - this.p.deltaX, offsetY - this.p.deltaY, this.imgEl.width, this.imgEl.height);
    }
  });

  // ctx.drawImage @imgEl, 0, 0
  Q = Game.Q;

  // animations object
  Q.animations("deadZombie", {
    intro: {
      frames: [16, 17, 18, 19, 20, 21],
      rate: 1 / 3,
      next: "stand"
    },
    stand: {
      frames: [21],
      rate: 1
    }
  });

  // human object and logic
  Q.Sprite.extend("DeadZombie", {
    init: function(p) {
      this._super(p, {
        x: 0,
        y: 0,
        vx: 0,
        z: 18,
        sheet: "zombie",
        sprite: "deadZombie",
        type: Game.SPRITE_NONE,
        collisionMask: Game.SPRITE_TILES
      });
      this.add("2d, animation");
      // animations
      return this.play("intro");
    }
  });

  Q = Game.Q;

  // animations object
  Q.animations("human", {
    intro: {
      frames: [0, 1, 2, 3],
      rate: 0.7,
      next: "stand"
    },
    stand: {
      frames: [4, 5, 6],
      rate: 1 / 3
    },
    outro: {
      frames: [3, 2, 1, 0],
      rate: 0.8,
      loop: false,
      trigger: "outro"
    }
  });

  // human object and logic
  Q.Sprite.extend("Human", {
    init: function(p) {
      this._super(p, {
        x: 0,
        y: 0,
        vx: 0,
        z: 20,
        timeInvincible: 4,
        sheet: "human",
        sprite: "human",
        type: Game.SPRITE_HUMAN,
        collisionMask: Game.SPRITE_TILES,
        sensor: true
      });
      this.add("2d, animation");
      // animations
      this.play("intro");
      // audio
      Q.AudioManager.addSoundFx(Game.audio.humanCreated);
      // events
      this.on("sensor", this, "sensor");
      return this.on("outro", this, "die");
    },
    step: function(dt) {
      if (this.p.timeInvincible > 0) {
        return this.p.timeInvincible = Math.max(this.p.timeInvincible - dt, 0);
      }
    },
    sensor: function(obj) {
      if (obj.isA("Zombie") && this.p.timeInvincible === 0) {
        // turn to zombie again
        obj.play("attack", 10);
        this.play("outro");
      }
      if (obj.isA("ZombiePlayer")) {
        this.play("outro");
        return this.p.zombiePlayerSensor = true;
      }
    },
    die: function() {
      var randomBool, zombie;
      this.destroy();
      randomBool = Math.floor(Math.random() * 2);
      zombie = this.stage.insert(new Q.Zombie({
        x: this.p.x,
        y: this.p.y,
        startLeft: randomBool
      }));
      if (!this.p.zombiePlayerSensor) {
        return zombie.p.wasHuman = true;
      }
    }
  });

  Q = Game.Q;

  // animations object
  Q.animations("player", {
    stand: {
      frames: [1],
      rate: 1
    },
    run: {
      frames: [0, 1, 2, 1],
      rate: 1 / 4
    },
    hit: {
      frames: [4],
      loop: false,
      rate: 1,
      next: "stand"
    },
    jump: {
      frames: [3, 4, 5, 4],
      rate: 1 / 3
    }
  });

  Q.animations("playerWithGun", {
    stand: {
      frames: [1],
      rate: 1
    },
    run: {
      frames: [0, 1, 2, 1],
      rate: 1 / 4
    },
    hit: {
      frames: [3],
      loop: false,
      rate: 1,
      next: "stand"
    },
    jump: {
      frames: [3],
      rate: 1
    }
  });

  // player object and logic
  Q.Sprite.extend("Player", {
    init: function(p) {
      this._super(p, {
        lifePoints: Q.state.get("lives"),
        timeInvincible: 0,
        timeToNextSave: 0,
        x: 0,
        y: 0,
        z: 100,
        savedPosition: {},
        hasKey: false,
        sheet: "player",
        sprite: "player",
        type: Game.SPRITE_PLAYER,
        collisionMask: Game.SPRITE_TILES | Game.SPRITE_ENEMY | Game.SPRITE_PLAYER_COLLECTIBLE
      });
      this.add("2d, animation");
      if (Game.settings.useKeyboardInstead.get()) {
        this.add("platformerControls");
      } else {
        this.add("platformerControlsGaze");
      }
      if (Q.state.get("hasGun")) {
        this.add("gun");
      }
      this.p.jumpSpeed = -660;
      this.p.speed = 220;
      this.p.savedPosition.x = this.p.x;
      this.p.savedPosition.y = this.p.y;
      // audio
      Q.AudioManager.addMusic(Game.audio.playerBg, {
        loop: true
      });
      // events
      this.on("bump.left, bump.right, bump.bottom, bump.top", this, "collision");
      return this.on("player.outOfMap", this, "restore");
    },
    step: function(dt) {
      var a, p, tri;
      // if invincible, flash opacity (with a triangle wave)
      if (this.p.timeInvincible > 0) {
        a = 0.3; // amplitude (triangle goes [-a, a])
        p = 1.25; // period
        tri = (2 * a / Math.PI) * Math.asin(Math.sin((2 * Math.PI / p) * this.p.timeInvincible));
        this.p.opacity = tri + (1.0 - a);
      } else {
        this.p.opacity = 1.0;
      }
      if (this.p.direction === "left") {
        this.p.flip = "x";
        this.p.points = [[-15, -50], [25, -50], [25, 50], [-15, 50]];
      }
      if (this.p.direction === "right") {
        this.p.flip = false;
        this.p.points = [[-25, -50], [15, -50], [15, 50], [-25, 50]];
      }
      // do not allow to get out of level
      if (this.p.x > Game.map.p.w) {
        this.p.x = Game.map.p.w;
      }
      if (this.p.x < 0) {
        this.p.x = 0;
      }
      // save
      if (this.p.timeToNextSave > 0) {
        this.p.timeToNextSave = Math.max(this.p.timeToNextSave - dt, 0);
      }
      if (this.p.timeToNextSave <= 0) {
        this.savePosition();
      }
      // collision with enemy timeout
      if (this.p.timeInvincible > 0) {
        this.p.timeInvincible = Math.max(this.p.timeInvincible - dt, 0);
      }
      // check if out of map
      if (this.p.y > Game.map.p.h) {
        this.updateLifePoints();
        this.trigger("player.outOfMap");
        this.p.willBeDead = false;
      }
      // animations
      if (this.p.vy !== 0) {
        this.play("jump");
      } else if (this.p.vx !== 0) {
        this.play("run");
      } else {
        this.play("stand");
      }
      // gun
      if (this.gunStep != null) {
        return this.gunStep(dt);
      }
    },
    collision: function(col) {
      if (col.obj.isA("Zombie") && this.p.timeInvincible === 0) {
        this.updateLifePoints();
        col.obj.play("attack", 10);
        // will be invincible for 1 second
        return this.p.timeInvincible = 3;
      }
    },
    savePosition: function() {
      var ground;
      ground = Q.stage().locate(this.p.x, this.p.y + this.p.h / 2 + 0.5, Game.SPRITE_TILES);
      if (ground) {
        this.p.savedPosition.x = this.p.x;
        this.p.savedPosition.y = this.p.y;
        return this.p.timeToNextSave = 2;
      }
    },
    updateLifePoints: function(newLives) {
      var isOutOfMap, zombiePlayer;
      if (newLives != null) {
        this.p.lifePoints += newLives;
      } else {
        isOutOfMap = this.p.y > Game.map.p.h;
        if (isOutOfMap) {
          Game.infoLabel.lifeLostFall();
        } else {
          Game.infoLabel.lifeLostZombie();
        }
        this.p.lifePoints -= 1;
        this.play("hit", 1);
        Q.AudioManager.addSoundFx(Game.audio.playerHit);
        if (this.p.lifePoints < 0) {
          if (this.p.wasZombie || isOutOfMap) {
            this.destroy();
            Game.stageGameOverScreen();
            return;
          }
          // zombie mode!
          zombiePlayer = this.stage.insert(new Q.ZombiePlayer({
            x: (() => {
              if (this.p.y > Game.map.p.h) {
                return this.p.savedPosition.x;
              } else {
                return this.p.x;
              }
            })(),
            y: (() => {
              if (this.p.y > Game.map.p.h) {
                return this.p.savedPosition.y;
              } else {
                return this.p.y;
              }
            })()
          }));
          Game.setCameraTo(this.stage, zombiePlayer);
          zombiePlayer.p.direction = this.p.direction;
          this.destroy();
        }
        if (this.p.lifePoints === 0) {
          Game.infoLabel.lifeLevelLow();
        }
      }
      // always update label
      return Q.state.set("lives", this.p.lifePoints);
    },
    restore: function() {
      this.p.timeInvincible = 5;
      this.p.x = this.p.savedPosition.x;
      this.p.y = this.p.savedPosition.y + 0.25 * Game.assets.map.tileSize;
      this.p.vx = 0;
      return this.p.vy = 0;
    }
  });

  Q = Game.Q;

  
  Q.animations("zombie", {
    run: {
      frames: [0, 1, 2, 3],
      rate: 0.4
    },
    hit: {
      frames: [10],
      loop: false,
      rate: 1,
      next: "run"
    },
    attack: {
      frames: [8, 9, 10, 11],
      loop: false,
      rate: 1 / 2,
      next: "run"
    },
    fall: {
      frames: [4, 5, 6, 7, 7, 7, 7],
      rate: 1 / 5,
      loop: false,
      next: "run"
    }
  });

  
  Q.Sprite.extend("Zombie", {
    init: function(p) {
      this._super(p, {
        lifePoints: 1,
        x: 0,
        y: 0,
        vx: 0,
        z: 20,
        canFallOff: true, // when chasing, zombie can fall off platform
        sheet: "zombie",
        sprite: "zombie",
        canSeeThePlayerTimeout: 0,
        type: Game.SPRITE_ENEMY,
        collisionMask: Game.SPRITE_TILES | Game.SPRITE_PLAYER | Game.SPRITE_BULLET | Game.SPRITE_HUMAN
      });
      Q.state.inc("enemiesCounter", 1);
      this.add("2d, animation, zombieAI");
      // events
      this.on("hit", this, "collision");
      this.on("bump.right", this, "hitFromRight");
      return this.on("bump.left", this, "hitFromLeft");
    },
    collision: function(col) {
      if (col.obj.isA("Bullet")) {
        this.play("hit");
        return this.decreaseLifePoints();
      }
    },
    hitFromRight: function(col) {
      // don't stop after collision
      return this.p.vx = col.impact;
    },
    hitFromLeft: function(col) {
      // don't stop after collision
      return this.p.vx = -col.impact;
    },
    step: function(dt) {
      if (this.zombieStep != null) {
        this.zombieStep(dt);
      }
      if (this.p.y > Game.map.p.h) {
        this.die(false);
      }
      // animations
      if (this.p.vy !== 0) {
        return this.play("fall");
      } else {
        return this.play("run");
      }
    },
    decreaseLifePoints: function() {
      this.p.lifePoints -= 1;
      if (this.p.lifePoints <= 0) {
        return this.die();
      }
    },
    die: function(turnToHuman = true) {
      this.destroy();
      if (!this.p.wasHuman && turnToHuman) {
        // replace zombie with human
        this.stage.insert(new Q.Human({
          x: this.p.x,
          y: this.p.y
        }));
      } else {
        this.stage.insert(new Q.DeadZombie({
          x: this.p.x,
          y: this.p.y
        }));
      }
      // update enemies counter
      return Q.state.dec("enemiesCounter", 1);
    }
  });

  Q = Game.Q;

  // animations object
  Q.animations("zombiePlayer", {
    stand: {
      frames: [4],
      rate: 1
    },
    run: {
      frames: [3, 4, 5, 4],
      rate: 1 / 3
    },
    jump: {
      frames: [3],
      rate: 1
    },
    intro: {
      frames: [0, 1, 0, 1, 0, 1],
      rate: 0.8,
      next: "stand",
      trigger: "ready"
    }
  });

  // main object and logic
  Q.Sprite.extend("ZombiePlayer", {
    init: function(p) {
      this._super(p, {
        timeToNextSave: 0,
        x: 0,
        y: 0,
        z: 100,
        savedPosition: {},
        sheet: "zombie_player",
        sprite: "zombiePlayer",
        type: Game.SPRITE_ZOMBIE_PLAYER,
        collisionMask: Game.SPRITE_TILES | Game.SPRITE_HUMAN | Game.SPRITE_PLAYER_COLLECTIBLE
      });
      this.add("2d, animation");
      this.p.jumpSpeed = -660;
      this.p.speed = 220;
      this.p.savedPosition.x = this.p.x;
      this.p.savedPosition.y = this.p.y;
      this.p.playerDirection = this.p.direction;
      Game.infoLabel.zombieModeOn();
      this.play("intro", 10);
      // events
      this.on("player.outOfMap", this, "die");
      return this.on("ready", this, "enableZombieMode");
    },
    enableZombieMode: function() {
      if (Game.settings.useKeyboardInstead.get()) {
        this.add("platformerControls");
      } else {
        this.add("platformerControlsGaze");
      }
      this.p.direction = this.p.playerDirection;
      Game.infoLabel.zombieModeOnNext();
      Game.currentLevelData.zombieModeFound = true;
      Game.playerAvatar.changeToZombie();
      Game.healthImg.changeToHalf();
      // audio
      Q.AudioManager.remove(Game.audio.playerBg);
      return Q.AudioManager.addMusic(Game.audio.zombieMode, {
        loop: true
      });
    },
    step: function(dt) {
      if (this.p.direction === "left") {
        this.p.flip = "x";
      }
      if (this.p.direction === "right") {
        this.p.flip = false;
      }
      // check if out of map
      if (this.p.y > Game.map.p.h) {
        this.trigger("player.outOfMap");
      }
      // do not allow to get out of level
      if (this.p.x > Game.map.p.w) {
        this.p.x = Game.map.p.w;
      }
      if (this.p.x < 0) {
        this.p.x = 0;
      }
      // save
      if (this.p.timeToNextSave > 0) {
        this.p.timeToNextSave = Math.max(this.p.timeToNextSave - dt, 0);
      }
      if (this.p.timeToNextSave === 0) {
        this.savePosition();
        this.p.timeToNextSave = 4;
      }
      // animations
      if (this.p.vy !== 0) {
        return this.play("jump");
      } else if (this.p.vx !== 0) {
        return this.play("run");
      } else {
        return this.play("stand");
      }
    },
    savePosition: function() {
      var dirX, ground;
      dirX = this.p.vx / Math.abs(this.p.vx);
      ground = Q.stage().locate(this.p.x, this.p.y + this.p.h / 2 + 1, Game.SPRITE_TILES);
      if (ground) {
        this.p.savedPosition.x = this.p.x;
        return this.p.savedPosition.y = this.p.y;
      }
    },
    die: function() {
      // zombie mode ends
      Game.stageGameOverScreen();
      return this.destroy();
    }
  });

  Q = Game.Q;

  Q.UI.ArrowDwellButton = Q.UI.PolygonButton.extend("UI.ArrowDwellButton", {
    init: function(p, defaultProps) {
      this._super(p, {
        type: Q.SPRITE_UI | Q.SPRITE_DEFAULT,
        fill: "#c4da4a",
        radius: 10,
        fontColor: "#353b47",
        font: "400 58px Jolly Lodger",
        faces_left: true
      });
      this.p.opacity = Number.parseFloat(Game.settings.uiOpacity.get());
      this.doDwell = false;
      if (this.p.h === void 0) {
        throw "cannot create arrow without height defined";
      }
      if (this.p.w === void 0) {
        throw "cannot create arrow without width defined";
      }
      this.p.points = this.get_interact_points();
      this.p.polygon = this.get_render_points();
      // Set up dwell/touch response
      if (this.p.hover_action) {
        this.on("hover", (e) => {
          return Q.inputs[this.p.hover_action] = 1;
        });
        this.on("touch", (e) => {
          Q.inputs[this.p.hover_action] = 1;
          if (e.touch instanceof Touch) {
            return Game.infoLabel.touch_advice();
          }
        });
        return this.on("touchEnd", (e) => {
          return Q.inputs[this.p.hover_action] = 0;
        });
      }
    },
    get_render_points: function() {
      var h, p, points, stem_h, stem_start, stem_w, w;
      // define some shapes for the main gaze controls  
      stem_h = this.p.h * .275; // varies height of arrow stem (from centre)
      stem_w = this.p.w * .05; // varies length of arrow stem (from centre)
      stem_start = this.p.w * 0.4; // varies how much stem is shrunk to balance the visual weight
      h = this.p.h;
      w = this.p.w;
      if (this.p.faces_left) {
        points = [[stem_start, -stem_h], [-stem_w, -stem_h], [-stem_w, -h / 2], [-w / 2, 0], [-stem_w, h / 2], [-stem_w, stem_h], [stem_start, stem_h]];
      } else {
        points = [[-stem_start, stem_h], [stem_w, stem_h], [stem_w, h / 2], [+w / 2, 0], [stem_w, -h / 2], [stem_w, -stem_h], [-stem_start, -stem_h]];
      }
      points = (function() {
        var j, len, results;
        results = [];
        for (j = 0, len = points.length; j < len; j++) {
          p = points[j];
          results.push([p[0] * 1.2, p[1] * 1.2]);
        }
        return results;
      })();
      return points;
    },
    // Quintus uses convex hull of 'points' property to capture mouse events
    // so if we have a concave shape, we need different 'points' to define
    // interactable part (not necessarily whole polygon drawn)
    // For the arrow, we ignore the tips of the arrow head that extend beyond the stem height
    get_interact_points: function() {
      var h, intersection_x, p, points, stem_h, stem_start, stem_w, w;
      stem_h = this.p.h * .275; // varies height of arrow stem (from centre)
      stem_w = this.p.w * .05; // varies length of arrow stem (from centre)
      stem_start = this.p.w * 0.4; // varies how much stem is shrunk to balance the visual weight
      h = this.p.h;
      w = this.p.w;
      if (this.p.faces_left) {
        intersection_x = w / 2 - (stem_h / h) * (w - 2 * stem_w); // intersection of stem and arrow
        points = [[stem_start, -stem_h], [-stem_w, -stem_h], [-intersection_x, -stem_h], [-w / 2, 0], [-intersection_x, stem_h], [-stem_w, stem_h], [stem_start, stem_h]];
      } else {
        intersection_x = w / 2 - (stem_h / h) * (w - 2 * stem_w); // intersection of stem and arrow
        points = [[-stem_start, stem_h], [stem_w, stem_h], [intersection_x, stem_h], [+w / 2, 0], [intersection_x, -stem_h], [stem_w, -stem_h], [-stem_start, -stem_h]];
      }
      points = (function() {
        var j, len, results;
        results = [];
        for (j = 0, len = points.length; j < len; j++) {
          p = points[j];
          results.push([p[0] * 1.2, p[1] * 1.2]);
        }
        return results;
      })();
      return points;
    }
  });

  Q = Game.Q;

  Q.UI.BulletsCounter = Q.UI.Text.extend("UI.BulletsCounter", {
    init: function(p) {
      this._super(p, {
        x: 0,
        y: 0,
        label: Q.state.get("bullets") + "",
        size: Styles.fontsize5,
        color: "#f2da38",
        family: "Boogaloo"
      });
      this.p.x = -this.p.img.w / 2 - this.p.w / 2 - 12;
      return Q.state.on("change.bullets", this, "updateLabel");
    },
    updateLabel: function(bullets) {
      return this.p.label = bullets + "";
    }
  });

  Q = Game.Q;

  Q.UI.BulletsImg = Q.Sprite.extend("Q.UI.BulletsImg", {
    init: function(p) {
      return this._super(p, {
        x: 0,
        y: 0,
        sheet: "hud_bullets"
      });
    }
  });

  Q = Game.Q;

  Q.UI.EnemiesAvatar = Q.Sprite.extend("Q.UI.EnemiesAvatar", {
    init: function(p) {
      this._super(p, {
        x: 0,
        y: 0,
        sheet: "hud_zombie"
      });
      this.p.x = Q.width - this.p.w / 2;
      return this.p.y = this.p.h / 2 + 8;
    }
  });

  Q = Game.Q;

  Q.UI.EnemiesCounter = Q.UI.Text.extend("UI.EnemiesCounter", {
    init: function(p) {
      this._super(p, {
        x: 0,
        y: 0,
        label: Q.state.get("enemiesCounter") + "",
        size: Styles.fontsize5,
        color: "#c4da4a",
        family: "Boogaloo"
      });
      this.p.w = 60;
      return Q.state.on("change.enemiesCounter", this, "updateLabel");
    },
    updateLabel: function(enemiesCounter) {
      return this.p.label = enemiesCounter + "";
    }
  });

  Q = Game.Q;

  Q.UI.HealthCounter = Q.UI.Text.extend("UI.HealthCounter", {
    init: function(p) {
      this._super(p, {
        x: 0,
        y: 0,
        label: Q.state.get("lives") + "",
        size: Styles.fontsize5,
        color: "#ec655d",
        family: "Boogaloo"
      });
      this.p.x = -this.p.img.w / 2 - this.p.w / 2 - 6;
      return Q.state.on("change.lives", this, "updateLabel");
    },
    updateLabel: function(lives) {
      if (lives >= 0) {
        return this.p.label = lives + "";
      } else {
        return this.p.label = "0";
      }
    }
  });

  Q = Game.Q;

  Q.UI.HealthImg = Q.Sprite.extend("Q.UI.HealthImg", {
    init: function(p) {
      return this._super(p, {
        x: 0,
        y: 0,
        sheet: "hud_health"
      });
    },
    changeToHalf: function() {
      return this.p.sheet = "hud_health_half";
    }
  });

  Q = Game.Q;

  Q.UI.InfoLabel = Q.UI.Text.extend("UI.InfoLabel", {
    init: function(p, defaultProps) {
      return this._super(p, {
        x: 0,
        y: 0,
        label: "",
        color: "#222221",
        size: Styles.fontsize2,
        family: "Boogaloo",
        pendingLabel: "",
        disabled: false,
        haveWarnedTouch: false
      });
    },
    disable: function() {
      return this.p.disabled = true;
    },
    enable: function() {
      return this.p.disabled = false;
    },
    speak: function(phrase) {
      if (Game.settings.narrationEnabled.get()) {
        return responsiveVoice.speak(phrase);
      }
    },
    changeLabel: function(new_label) {
      var self;
      if (!this.p.disabled) {
        if (new_label === this.pendingLabel) {
          return;
        }
        this.pendingLabel = new_label;
        this.afterLabelChange("...");
        self = this;
        return setTimeout((function() {
          self.afterLabelChange(new_label);
          return self.speak(new_label);
        }), 250);
      }
    },
    afterLabelChange: function(new_label) {
      if (new_label) {
        this.p.label = new_label;
      }
      this.calcSize();
      this.p.container.p.x = this.p.offsetLeft + this.p.w / 2 + 10;
      this.p.container.fit(5, 10);
      return Q._generatePoints(this);
    },
    touch_advice: function() {
      if (!this.haveWarnedTouch) {
        this.changeLabel("If you're using touch, you'll need to hold down the arrow to walk");
        return this.haveWarnedTouch = true;
      }
    },
    tutorial: function() {
      return this.changeLabel("If you can complete this tutorial you're ready to save some zombies");
    },
    intro: function() {
      return this.changeLabel("I need to find the way out of here");
    },
    keyNeeded: function() {
      return this.changeLabel("I need the key");
    },
    doorOpen: function() {
      if (Game.settings.useKeyboardInstead.get()) {
        return this.changeLabel("Nice! Now I need to 'jump' into the door");
      } else {
        return this.changeLabel("Nice! Now I need to enter the door");
      }
    },
    gunFound: function() {
      return this.changeLabel("I found the gun, I can shoot zombies");
    },
    moreBullets: function() {
      this.p.label = "I found more bullets!";
      return this.afterLabelChange();
    },
    outOfBullets: function() {
      return this.changeLabel("I'm out of ammo");
    },
    keyFound: function() {
      return this.changeLabel("I found the key, now I need to find the door");
    },
    clear: function() {
      return this.afterLabelChange("");
    },
    lifeLevelLow: function() {
      return this.changeLabel("No more spare lives! I need to be more careful");
    },
    extraLifeFound: function() {
      return this.changeLabel("I feel better now!");
    },
    lifeLostZombie: function() {
      var label, random;
      random = Math.floor(Math.random() * 3);
      if (random === 0) {
        label = "Ouch!";
      } else if (random === 1) {
        label = "I've been bitten!";
      } else {
        label = "That hurts!";
      }
      return this.changeLabel(label);
    },
    lifeLostFall: function() {
      var label, random;
      random = Math.floor(Math.random() * 3);
      if (random === 0) {
        label = "Ouch!";
      } else if (random === 1) {
        label = "Oops!";
      } else {
        label = "That hurt!";
      }
      return this.changeLabel(label);
    },
    zombieModeOn: function() {
      return this.changeLabel("I was bitten too many times. ");
    },
    zombieModeOnNext: function() {
      return this.changeLabel("I've turned into a zombie. Nooo!");
    },
    zombieModeOff: function() {
      return this.changeLabel("Ok, back to business");
    }
  });

  Q = Game.Q;

  Q.UI.InventoryKey = Q.Sprite.extend("Q.UI.InventoryKey", {
    init: function(p) {
      this._super(p, {
        x: 0,
        y: 0,
        sheet: "hud_key_empty"
      });
      return Q.state.on("change.hasKey", this, "updateSheet");
    },
    updateSheet: function(hasKey) {
      if (hasKey === true) {
        return this.p.sheet = "hud_key_collected";
      } else {
        return this.p.sheet = "hud_key_empty";
      }
    }
  });

  Q = Game.Q;

  Q.UI.JumpDwellButton = Q.UI.PolygonButton.extend("UI.JumpDwellButton", {
    init: function(p, defaultProps) {
      this._super(p, {
        type: Q.SPRITE_UI | Q.SPRITE_DEFAULT,
        fill: "#c4da4a",
        radius: 10,
        fontColor: "black",
        font: "400 58px Jolly Lodger",
        faces_left: true
      });
      this.p.opacity = Number.parseFloat(Game.settings.uiOpacity.get());
      this.doDwell = true;
      if (this.p.h === void 0) {
        throw "cannot create jump arrow without height defined";
      }
      if (this.p.w === void 0) {
        throw "cannot create jump arrow without width defined";
      }
      this.p.points = this.get_interact_points();
      this.p.polygon = this.get_render_points();
      // Set up dwell/touch response
      if (this.p.dwell_action) {
        return this.on("click", function(e) {
          Q.inputs[this.p.dwell_action] = 1;
          return Q.input.trigger(this.p.dwell_action);
        });
      }
    },
    get_render_points: function() {
      var h, leftjump_normalised, p, points, rightjump_normalised, w;
      // shapes figured out in inkscape and hardcoded     
      leftjump_normalised = [[0.5, 0.5], [0.5, 0.15], [0.428571428571429, -0.0714285714285714], [0.214285714285714, -0.321428571428571], [0.428571428571429, -0.5], [-0.5, -0.5], [-0.5, 0.321428571428571], [-0.321428571428571, 0.142857142857143], [-0.214285714285714, 0.25], [-0.214285714285714, 0.5]];
      rightjump_normalised = [[-0.5, 0.5], [-0.5, 0.15], [-0.428571428571429, -0.0714285714285714], [-0.214285714285714, -0.321428571428571], [-0.428571428571429, -0.5], [0.5, -0.5], [0.5, 0.321428571428571], [0.321428571428571, 0.142857142857143], [0.214285714285714, 0.25], [0.214285714285714, 0.5]];
      if (this.p.faces_left) {
        points = leftjump_normalised;
      } else {
        points = rightjump_normalised;
      }
      // scale up
      h = this.p.h;
      w = this.p.w;
      points = (function() {
        var j, len, results;
        results = [];
        for (j = 0, len = points.length; j < len; j++) {
          p = points[j];
          results.push([p[0] * w * .9, p[1] * h * .9]);
        }
        return results;
      })();
      return points;
    },
    get_interact_points: function() {
      var h, leftjump_normalised, p, points, rightjump_normalised, w;
      
      // same shape, but any bits that cause the convex hull to stick 
      // out the shape have been chopped off (approximately)
      leftjump_normalised = [[0.5, 0.5], [0.5, 0.15], [0.428571428571429, -0.0714285714285714], [0.214285714285714, -0.321428571428571], [0.0, -0.5], [-0.5, -0.5], [-0.5, 0.0], [-0.321428571428571, 0.142857142857143], [-0.214285714285714, 0.25], [-0.0, 0.5]];
      rightjump_normalised = [[-0.5, 0.5], [-0.5, 0.15], [-0.428571428571429, -0.0714285714285714], [-0.214285714285714, -0.321428571428571], [-0.0, -0.5], [0.5, -0.5], [0.5, 0.0], [0.321428571428571, 0.142857142857143], [0.214285714285714, 0.25], [0.0, 0.5]];
      if (this.p.faces_left) {
        points = leftjump_normalised;
      } else {
        points = rightjump_normalised;
      }
      // scale up
      h = this.p.h;
      w = this.p.w;
      points = (function() {
        var j, len, results;
        results = [];
        for (j = 0, len = points.length; j < len; j++) {
          p = points[j];
          results.push([p[0] * w * .9, p[1] * h * .9]);
        }
        return results;
      })();
      return points;
    }
  });

  Q = Game.Q;

  Q.UI.LinearGradient = Q.Sprite.extend("Q.UI.LinearGradient", {
    init: function(p) {
      return this._super(p, {
        x: 0,
        y: 0,
        z: 0,
        asset: Game.assets.gradient
      });
    },
    draw: function(ctx) {
      var img, ptrn;
      img = this.asset();
      ptrn = ctx.createPattern(img, 'repeat');
      ctx.fillStyle = ptrn;
      return ctx.fillRect(0, 0, Q.width, this.p.h);
    }
  });

  Q = Game.Q;

  Q.UI.PlayerAvatar = Q.Sprite.extend("Q.UI.PlayerAvatar", {
    init: function(p) {
      this._super(p, {
        x: 0,
        y: 0,
        sheet: "hud_player"
      });
      this.p.x = this.p.w / 2;
      return this.p.y = this.p.h / 2;
    },
    changeToZombie: function() {
      return this.p.sheet = "hud_zombie_player";
    },
    changeToPlayer: function() {
      return this.p.sheet = "hud_player";
    }
  });

  Q = Game.Q;

  Q.UI.RadialGradient = Q.Sprite.extend("Q.UI.RadialGradient", {
    init: function(p) {
      this._super(p, {
        x: Q.width / 2,
        y: Q.height / 2,
        w: Q.width,
        h: Q.height
      });
      return console.log(this.p);
    },
    draw: function(ctx) {
      var rad;
      rad = ctx.createRadialGradient(0, 0, this.p.w / 3, 0, 0, this.p.w / 2 + this.p.w / 4);
      rad.addColorStop(0, 'rgba(0,0,0,0)');
      rad.addColorStop(1, 'rgba(0,0,0,1)');
      // rad.addColorStop(0, 'rgba(255,0,0,0.5)')
      // rad.addColorStop(1, 'rgba(0,255,0,1)')
      ctx.fillStyle = rad;
      ctx.fillRect(-this.p.cx, -this.p.cy, this.p.w, this.p.h);
      return ctx.fill();
    }
  });

  Q = Game.Q;

  // animations object
  Q.animations("bullet", {
    fly: {
      frames: [0, 1, 2, 3, 4, 5],
      rate: 0.3
    }
  });

  Q.Sprite.extend("Bullet", {
    init: function(p) {
      this._super(p, {
        range: Q.width / 2,
        sheet: "bullet",
        sprite: "bullet",
        speed: 700,
        gravity: 0,
        type: Game.SPRITE_BULLET,
        collisionMask: Game.SPRITE_TILES | Game.SPRITE_ENEMY
      });
      this.add("2d, animation");
      this.play("fly");
      this.p.initialX = this.p.x;
      this.p.initialY = this.p.y;
      return this.on("hit", this, "collision");
    },
    step: function(dt) {
      if (this.p.direction === "left") {
        this.p.vx = -this.p.speed;
        this.p.flip = "x";
      } else {
        this.p.vx = this.p.speed;
        this.p.flip = false;
      }
      if (this.p.x > Game.map.width || this.p.x < 0) {
        this.die();
      }
      if (this.p.x > this.p.initialX + this.p.range || this.p.x < this.p.initialX - this.p.range) {
        return this.die();
      }
    },
    collision: function(col) {
      this.p.x -= col.separate[0];
      this.p.y -= col.separate[1];
      // difference for level statistics
      if (col.obj.isA("Zombie")) {
        return this.destroy();
      } else {
        return this.die();
      }
    },
    die: function() {
      Game.currentLevelData.bullets.waisted += 1;
      return this.destroy();
    }
  });

  Q = Game.Q;

  Q.Sprite.extend("Door", {
    init: function(p) {
      this._super(p, {
        x: 0,
        y: 0,
        z: 10,
        sheet: "door_closed",
        opened: false,
        type: Game.SPRITE_PLAYER_COLLECTIBLE,
        sensor: true
      });
      this.p.y -= this.p.h / 2 - Game.assets.map.tileSize / 2;
      // events
      return this.on("sensor", this, "sensor");
    },
    sensor: function(obj) {
      if (obj.isA("Player") || obj.isA("ZombiePlayer")) {
        if ((Q.state.get("hasKey")) && !this.p.opened) {
          // remove the key and open the door
          Q.state.set("hasKey", false);
          this.p.opened = true;
          this.p.sheet = "door_open";
          Q.state.set("canEnterDoor", true);
          return Game.infoLabel.doorOpen();
        } else if (!this.p.opened) {
          return Game.infoLabel.keyNeeded();
        } else if (this.p.opened && (Q.inputs['up'] || Q.inputs['action'] || Q.inputs['enter'])) {
          // enter the door
          obj.destroy();
          Q.inputs['enter'] = 0;
          // get game statistics
          Game.currentLevelData.zombies.healed = this.stage.lists.Human != null ? this.stage.lists.Human.length : 0;
          if (Q.state.get("currentLevel") > 0) {
            return Game.stageEndLevelScreen();
          } else {
            Q.clearStages();
            Q.stageScene("tutorialSummary", Game.currentLevelData);
            return Game.currentScreen = "tutorialSummary";
          }
        }
      }
    }
  });

  Q = Game.Q;

  Q.Sprite.extend("ExitSign", {
    init: function(p) {
      this._super(p, {
        x: 0,
        y: 0,
        z: 10,
        sheet: "exit_sign",
        type: Game.SPRITE_NONE
      });
      return this.p.y -= this.p.h / 2 - Game.assets.map.tileSize / 2;
    }
  });

  Q = Game.Q;

  Q.Sprite.extend("Gun", {
    init: function(p) {
      this._super(p, {
        x: 0,
        y: 0,
        z: 10,
        sheet: "gun",
        type: Game.SPRITE_PLAYER_COLLECTIBLE,
        sensor: true,
        bullets: 6
      });
      this.p.y -= 15;
      // events
      return this.on("sensor", this, "sensor");
    },
    sensor: function(obj) {
      if (obj.isA("Player")) {
        if (Q.state.get("hasGun")) {
          Game.infoLabel.moreBullets();
        } else {
          Q.state.set("hasGun", true);
          obj.add("gun");
          Game.infoLabel.gunFound();
        }
        // number of bullets depends of the gun
        Q.state.inc("bullets", this.p.bullets);
        Game.currentLevelData.bullets.available = Q.state.get("bullets");
        Q.AudioManager.addSoundFx(Game.audio.collected);
        return this.destroy();
      }
    }
  });

  Q = Game.Q;

  Q.Sprite.extend("Heart", {
    init: function(p) {
      this._super(p, {
        x: 0,
        y: 0,
        z: 10,
        sheet: "heart",
        type: Game.SPRITE_PLAYER_COLLECTIBLE,
        sensor: true
      });
      this.p.y -= 15;
      // events
      return this.on("sensor", this, "sensor");
    },
    sensor: function(obj) {
      if (obj.isA("Player")) {
        obj.updateLifePoints(1);
        Game.infoLabel.extraLifeFound();
        Q.AudioManager.addSoundFx(Game.audio.collected);
        this.destroy();
        return Game.currentLevelData.health.collected += 1;
      }
    }
  });

  Q = Game.Q;

  Q.Sprite.extend("InfoPoint", {
    init: function(p) {
      this._super(p, {
        x: 0,
        y: 0,
        w: 10 * Game.assets.map.tileSize,
        h: 10 * Game.assets.map.tileSize,
        z: 10,
        type: Game.SPRITE_PLAYER_COLLECTIBLE,
        sensor: true
      });
      this.p.y -= this.p.h / 2 - Game.assets.map.tileSize / 2;
      // events
      this.on("sensor", this, "sensor");
      return this.already_spoken = false;
    },
    sensor: function(obj) {
      if (!this.already_spoken) {
        if (obj.isA("Player") || obj.isA("ZombiePlayer")) {
          if (Game.settings.narrationEnabled.get() && this.p.label) {
            responsiveVoice.speak(this.p.label);
            return this.already_spoken = true;
          }
        }
      }
    }
  });

  Q = Game.Q;

  Q.Sprite.extend("Key", {
    init: function(p) {
      this._super(p, {
        x: 0,
        y: 0,
        z: 10,
        sheet: "key",
        type: Game.SPRITE_PLAYER_COLLECTIBLE,
        sensor: true
      });
      // range: 6
      // speed: 6
      // gravity: 0
      this.p.y -= 15;
      // @add("2d")
      // @p.initialY = @p.y
      // @p.vy = @p.speed

      // events
      return this.on("sensor", this, "sensor");
    },
    sensor: function(obj) {
      if (obj.isA("Player") || obj.isA("ZombiePlayer")) {
        Q.state.set("hasKey", true);
        Game.infoLabel.keyFound();
        Q.AudioManager.addSoundFx(Game.audio.collected);
        return this.destroy();
      }
    }
  });

  // step: (dt) ->
  //   if @p.initialY + @p.range < @p.y
  //     @p.vy = -@p.speed

  //   if @p.initialY - @p.range > @p.y
  //     @p.vy = @p.speed
  Q = Game.Q;

  Q.UI.ArrowButton = Q.UI.Button.extend("UI.ArrowButton", {
    init: function(p) {
      this._super(p, {
        type: Q.SPRITE_UI | Q.SPRITE_DEFAULT,
        sheet: "arrow_button",
        fontColor: "#595f5f",
        font: "400 32px Jolly Lodger",
        page: 0,
        fontColor: "#404444",
        align: 'center',
        flip: false
      });
      this.p.sheetW = 172;
      this.p.sheetH = 130;
      this.p.cx = this.p.sheetW / 2;
      this.p.cy = this.p.sheetH / 2;
      if (!this.p.enabled) {
        this.p.opacity = 0.4;
      }
      return this.on('click', () => {
        if (this.p.enabled) {
          return Game.stageMoreLevels(this.p.page);
        }
      });
    }
  });

  Q = Game.Q;

  Q.UI.AudioButton = Q.UI.Button.extend("UI.AudioButton", {
    init: function(p) {
      this._super(p, {
        x: 0,
        y: 0,
        type: Q.SPRITE_UI | Q.SPRITE_DEFAULT,
        keyActionName: "mute", // button that will trigger click event
        isSmall: true,
        isMuted: false
      });
      this.updateSheet();
      return this.size(true); // force resize 
    },
    updateSheet: function() {
      if (this.p.isSmall) {
        if (this.p.isMuted) {
          return this.p.sheet = "hud_audio_off_button_small";
        } else {
          return this.p.sheet = "hud_audio_on_button_small";
        }
      } else {
        if (this.p.isMuted) {
          return this.p.sheet = "hud_audio_off_button";
        } else {
          return this.p.sheet = "hud_audio_on_button";
        }
      }
    },
    setMuted: function(isMuted) {
      this.p.isMuted = isMuted;
      return this.updateSheet();
    }
  });

  Q = Game.Q;

  Q.UI.Authors = Q.UI.Text.extend("UI.Authors", {
    init: function(p) {
      this._super(p, {
        label: "Created by @krzysu and @pawelmadeja, extended and adapted for eye gaze by @SpecialEffect",
        color: "#c4da4a",
        family: "Boogaloo",
        size: Styles.fontsize1
      });
      this.p.x = Q.width / 2;
      return this.p.y = Q.height - this.p.h / 2;
    }
  });

  Q = Game.Q;

  Q.UI.Checkbox = Q.UI.Button.extend("UI.Checkbox", {
    init: function(p) {
      this._super(p, {
        x: 0,
        y: 0,
        type: Q.SPRITE_UI | Q.SPRITE_DEFAULT,
        checked: false,
        sheet: "checkbox"
      });
      this.size(true); // force resize     
      return this.on('click', () => {
        return this.checked = !this.checked;
      });
    },
    draw: function(ctx) {
      this._super(ctx);
      // Q.sheet("checkbox").draw(ctx, -@p.cx, -@p.cy, @p.frame);
      if (this.checked) {
        return Q.sheet("checkbox_checked").draw(ctx, -this.p.cx, -this.p.cy, this.p.frame);
      }
    }
  });

  Q = Game.Q;

  Q.CompositeUI = {
    setup_settings_page: function(stage, page_title) {
      var backLayout, button, buttonBar, buttonTextSize, label, mainSection, pageContainer, title, titleBar;
      // Audio
      Q.AudioManager.stopAll();
      Q.AudioManager.clear();
      // Layouts
      pageContainer = stage.insert(new Q.UI.Container({
        x: Q.width / 2,
        y: Q.height / 2,
        w: Q.width,
        h: Q.height
      }));
      titleBar = stage.insert(pageContainer.subplot(8, 1, 0, 0));
      mainSection = pageContainer.subplot_multiple(8, 1, 1, 0, 6, 0);
      buttonBar = stage.insert(pageContainer.subplot(8, 1, 7, 0));
      
      // Title
      title = titleBar.insert(new Q.UI.Text({
        label: page_title,
        color: "#f2da38",
        family: "Jolly Lodger",
        size: titleBar.p.h * 0.8
      }));
      // back button
      backLayout = buttonBar; //stage.insert buttonBar.subplot(1,2,0,1)
      label = "Back";
      buttonTextSize = Q.ctx.measureText(label);
      button = backLayout.insert(new Q.UI.Button({
        w: buttonTextSize.width * 1.3,
        h: 80,
        fill: "#c4da4a",
        radius: 10,
        fontColor: "#353b47",
        font: "400 58px Jolly Lodger",
        label: label,
        keyActionName: "escape",
        type: Q.SPRITE_UI | Q.SPRITE_DEFAULT
      }));
      button.on("click", function(e) {
        if (Game.currentScreen === "settings_menu") {
          return Game.stageLevelSelectScreen();
        } else {
          return Game.stageScreen("settings_menu");
        }
      });
      return [titleBar, mainSection, buttonBar];
    },
    add_cursor_warning: function(cursor_layout, x, y) {
      var cursorIcon, cursorWarning, delta, rescale, text_shift, update_warning_visibility, y_shift;
      cursorWarning = cursor_layout.insert(new Q.UI.Text({
        label: "Cursor is currently hidden;\npress 'C' to show cursor",
        color: "#c4da4a",
        family: "Arial",
        size: Styles.fontsize0,
        x: x,
        y: y
      }));
      cursorIcon = cursor_layout.insert(new Q.UI.WarningIcon({
        x: x,
        y: y
      }));
      // Adjust scale of icon
      rescale = cursorWarning.p.h / cursorIcon.p.h;
      cursorIcon.p.scale = rescale;
      cursorIcon.size();
      // Shift both to sit alongside    
      delta = cursorWarning.p.w / 2 + cursorIcon.p.w * rescale * 0.75;
      text_shift = 0.25;
      cursorWarning.p.x += delta * text_shift;
      cursorIcon.p.x -= delta * (1 - text_shift);
      // Align bottom of warning with bottom of text for balance (ish)
      y_shift = cursorWarning.p.h * 0.1;
      cursorIcon.p.y -= y_shift;
      update_warning_visibility = function() {
        if (Q.state.get("showCursor")) {
          cursorWarning.p.opacity = 0.0;
          return cursorIcon.p.opacity = 0.0;
        } else {
          cursorWarning.p.opacity = 1.0;
          return cursorIcon.p.opacity = 1.0;
        }
      };
      Q.state.on("change.showCursor", update_warning_visibility);
      return update_warning_visibility();
    },
    add_exclusive_toggle_buttons: function(layout, btn1_opts, btn2_opts, label) {
      var button1, button2, callback1, callback1_click, callback2, callback2_click, cellsize, darkgray, gray, h, label1, label2, label_height, label_width, main_label, panel, rescale, title_fontsize, title_panel, w, x, y, yellow;
      // callback method takes args (is_checked, is_initialising)
      // When setting up the UI, is_initialising=True. Callbacks from 
      // user actions have is_initialising=False
      h = layout.p.h;
      w = layout.p.w;
      gray = "#818793";
      darkgray = "#272828";
      yellow = "#f2da38";
      // Background panel to hold elements together visually    
      // (we'll size it later)
      panel = layout.insert(new Q.UI.Container({
        fill: "#e3ecf933",
        radius: 12,
        w: 10,
        h: 10,
        type: Q.SPRITE_UI | Q.SPRITE_DEFAULT
      }));
      // Title panel
      title_panel = layout.insert(new Q.UI.Container({
        fill: "#e3ecf933",
        radius: 6,
        w: 10,
        h: 10,
        type: Q.SPRITE_UI | Q.SPRITE_DEFAULT
      }));
      title_fontsize = Math.floor(h / 6.5);
      label1 = layout.insert(new Q.UI.Text({
        label: btn1_opts.label,
        color: "#f2da38",
        family: "Boogaloo",
        size: title_fontsize
      }));
      label1.p.y -= (h - label1.p.h) / 2;
      label2 = layout.insert(new Q.UI.Text({
        y: label1.p.y,
        label: btn2_opts.label,
        color: "#f2da38",
        family: "Boogaloo",
        size: title_fontsize
      }));
      label_width = 0;
      label_height = 0;
      main_label = layout.insert(new Q.UI.Text({
        label: label,
        y: label1.p.h / 2,
        color: darkgray,
        family: "Jolly Lodger",
        size: title_fontsize,
        align: "center"
      }));
      x = 0;
      y = 0;
      cellsize = Math.min(h, w / 3) - label1.p.h;
      label1.p.x = -cellsize;
      label2.p.x = +cellsize;
      // Panel sizing    
      panel.p.w = 3 * cellsize;
      panel.p.h = cellsize;
      panel.p.x = -panel.p.w / 2 + 5;
      panel.p.y = -panel.p.h / 2 + label1.p.h / 2 + 5;
      title_panel.p.w = label_width * 1.3;
      title_panel.p.h = label_height * 1.3;
      title_panel.p.x = -title_panel.p.w / 2 + 5;
      title_panel.p.y = -title_panel.p.h / 2 + label1.p.h / 2 + 5;
      
      // Left hand: btn1
      button1 = layout.insert(new Q.UI.ToggleButton({
        type: Q.SPRITE_UI | Q.SPRITE_DEFAULT,
        x: -cellsize,
        y: label1.p.h / 2,
        do_toggle: false,
        btn_sheet: btn1_opts.sheet
      }));
      if (btn1_opts.doDwell != null) {
        button1.doDwell = btn1_opts.doDwell;
      }
      // Right hand: btn2
      button2 = layout.insert(new Q.UI.ToggleButton({
        type: Q.SPRITE_UI | Q.SPRITE_DEFAULT,
        x: +cellsize,
        y: label1.p.h / 2,
        do_toggle: false,
        btn_sheet: btn2_opts.sheet
      }));
      if (btn2_opts.doDwell != null) {
        button2.doDwell = btn2_opts.doDwell;
      }
      // If icon missing, replace title with labels in centre
      // (we don't move the existing label since z order is as bit fragile in quintus)
      if (btn1_opts.sheet == null) {
        label1.p.hidden = true;
        label1 = layout.insert(new Q.UI.Text({
          x: label1.p.x,
          y: label1.p.y + cellsize / 2 + label1.p.h / 2,
          label: btn1_opts.label,
          color: "#f2da38",
          family: "Boogaloo",
          size: title_fontsize
        }));
      }
      if (btn2_opts.sheet == null) {
        label2.p.hidden = true;
        label2 = layout.insert(new Q.UI.Text({
          x: label2.p.x,
          y: label2.p.y + cellsize / 2 + label2.p.h / 2,
          label: btn2_opts.label,
          color: "#f2da38",
          family: "Boogaloo",
          size: title_fontsize
        }));
      }
      // Rescale buttons to fit
      rescale = cellsize / Math.max(button1.p.h, button1.p.w);
      console.log('rescaling by %.3f', rescale);
      rescale *= 0.95;
      button1.p.scale = rescale;
      button2.p.scale = rescale;
      // button1.size()
      // button2.size()

      // Callbacks
      callback1 = function(e) {
        button1.pressed = true;
        label1.p.color = yellow;
        button2.pressed = false;
        label2.p.color = gray;
        return btn1_opts.on_click(e);
      };
      callback2 = function(e) {
        button1.pressed = false;
        label1.p.color = gray;
        button2.pressed = true;
        label2.p.color = yellow;
        return btn2_opts.on_click(e);
      };
      callback1_click = function() {
        return callback1(false);
      };
      callback2_click = function() {
        return callback2(false);
      };
      button1.on("click", callback1_click);
      button2.on("click", callback2_click);
      
      // Initial state: equivalent to clicking one of them
      if (btn1_opts.init_state) {
        return callback1(true);
      } else {
        return callback2(true);
      }
    },
    add_checkbox: function(layout, label, callback) {
      var chk, delta, fontsize, h, rescale, w;
      h = layout.p.h;
      w = layout.p.w;
      chk = layout.insert(new Q.UI.Checkbox);
      rescale = layout.p.h * 0.75 / chk.p.h;
      chk.p.scale = rescale;
      if (callback != null) {
        chk.on("click", function(e) {
          return callback(chk.checked);
        });
      }
      fontsize = Math.floor(h / 5);
      label = layout.insert(new Q.UI.Text({
        label: label,
        color: "#f2da38",
        family: "Boogaloo",
        size: fontsize
      }));
      delta = label.p.w / 2 + rescale * chk.p.w / 2;
      
      // if label.p.w + chk.p.w + delta > layout.p.h
      // delta = layout.p.h - (label.p.w + chk.p.w)
      label.p.x += delta / 2;
      chk.p.x -= delta / 2;
      return chk;
    },
    add_adjuster: function(layout, label, getter, setter, inc = 0.1, min_val, max_val) {
      var cellsize, decButton, fontsize, fontsize_symbols, h, incButton, init_val, num_digits, title, title_fontsize, updateCallback, valText, w, x, y;
      // Add 2 buttons that increment/decrement a label in the middle
      h = layout.p.h;
      w = layout.p.w;
      num_digits = Math.ceil(-Math.log10(inc * 1.05)); // *1.05 to avoid rounding exaggerations
      title_fontsize = Math.floor(h / 6.5);
      title = new Q.UI.Text({
        label: label,
        color: "#f2da38",
        family: "Boogaloo",
        size: title_fontsize
      });
      title.p.y -= (h - title.p.h) / 2;
      layout.insert(title);
      x = 0;
      y = 0;
      cellsize = Math.min(h, w / 3) - title.p.h;
      fontsize = Math.floor(h / 5);
      fontsize_symbols = Math.floor(h / 2);
      init_val = getter();
      
      // Left hand: decrement
      decButton = layout.insert(new Q.UI.Button({
        x: -cellsize,
        y: title.p.h / 2,
        fill: "#c4da4a",
        w: cellsize,
        h: cellsize,
        radius: 10,
        fontColor: "#353b47",
        font: "400 80px Jolly Lodger",
        label: "-",
        type: Q.SPRITE_UI | Q.SPRITE_DEFAULT
      }));
      // Right hand: increment
      incButton = layout.insert(new Q.UI.Button({
        x: cellsize,
        fill: "#c4da4a",
        y: title.p.h / 2,
        w: cellsize,
        h: cellsize,
        radius: 10,
        fontColor: "#353b47",
        font: "400 " + fontsize_symbols + "px Jolly Lodger",
        label: "+",
        type: Q.SPRITE_UI | Q.SPRITE_DEFAULT
      }));
      // Value for setting
      valText = layout.insert(new Q.UI.Text({
        x: x,
        y: title.p.h / 2,
        label: init_val.toFixed(num_digits),
        color: "#f2da38",
        family: "Boogaloo",
        size: fontsize
      }));
      // Callbacks
      decButton.on("click", function(e) {
        var new_val;
        new_val = getter() - inc;
        if ((min_val != null) && new_val < min_val) {
          new_val = min_val;
        }
        setter(new_val);
        return valText.p.label = getter().toFixed(num_digits);
      });
      incButton.on("click", function(e) {
        var new_val;
        new_val = getter() + inc;
        if ((max_val != null) && new_val > max_val) {
          new_val = max_val;
        }
        setter(new_val);
        return valText.p.label = getter().toFixed(num_digits);
      });
      updateCallback = function(new_val) {
        setter(new_val);
        return valText.p.label = getter().toFixed(num_digits);
      };
      return updateCallback;
    }
  };

  Q = Game.Q;

  Q.UI.CursorButton = Q.UI.Button.extend("UI.CursorButton", {
    init: function(p) {
      this._super(p, {
        x: 0,
        y: 0,
        type: Q.SPRITE_UI | Q.SPRITE_DEFAULT,
        keyActionName: "show_cursor", // button that will trigger click event
        isSmall: true
      });
      this.update_sheet(p);
      this.size(true); // force resize 
      Q.state.on("change.showCursor", this, "update_sheet");
      return this.on('click', () => {
        return Game.toggleCursor();
      });
    },
    update_sheet: function() {
      if (this.p.isSmall) {
        if (Q.state.get("showCursor")) {
          return this.p.sheet = "hud_cursor_on_button_small";
        } else {
          return this.p.sheet = "hud_cursor_off_button_small";
        }
      } else {
        if (Q.state.get("showCursor")) {
          return this.p.sheet = "hud_cursor_on_button";
        } else {
          return this.p.sheet = "hud_cursor_off_button";
        }
      }
    }
  });

  Q = Game.Q;

  Q.UI.CursorWarning = Q.UI.Text.extend("UI.CursorWarning", {
    init: function(p) {
      this._super(p, {
        label: "Cursor is currently hidden; to show cursor press 'C'",
        color: "#c4da4a",
        family: "Boogaloo",
        family: "Arial",
        size: Styles.fontsize0
      });
      this.p.x = Q.width / 2;
      this.p.y = this.p.h * .75;
      this.update_visibility();
      return Q.state.on("change.showCursor", this, "update_visibility");
    },
    update_visibility: function() {
      if (Q.state.get("showCursor")) {
        return this.p.opacity = 0.0;
      } else {
        return this.p.opacity = 1.0;
      }
    }
  });

  Q = Game.Q;

  Q.UI.DoorButton = Q.UI.Button.extend("UI.DoorButton", {
    init: function(p) {
      var onChangeHidden;
      this._super(p, {
        type: Q.SPRITE_UI | Q.SPRITE_DEFAULT,
        w: 120,
        h: 120,
        hidden: true,
        fill: "#c4da4a",
        radius: 10,
        fontColor: "#353b47",
        font: "400 58px Jolly Lodger",
        label: "enter",
        type: Q.SPRITE_UI | Q.SPRITE_DEFAULT
      });
      if (this.p.enabled === false) {
        this.p.sheet = "ui_level_button_locked";
        this.p.label = false;
      }
      this.on("click", function(e) {
        Q.inputs['enter'] = 1;
        return Q.input.trigger('enter');
      });
      onChangeHidden = (ctx) => {
        return () => {
          return ctx.p.hidden = !Q.state.get("canEnterDoor");
        };
      };
      return Q.state.on("change.canEnterDoor", onChangeHidden(this));
    }
  });

  Q = Game.Q;

  Q.UI.HelpText = Q.UI.Text.extend("UI.Text", {
    init: function(p) {
      return this._super(p, {
        label: "",
        color: "#f2da38",
        family: "Jolly Lodger",
        size: Styles.fontsize4
      });
    }
  });

  Q = Game.Q;

  Q.UI.LevelButton = Q.UI.Button.extend("UI.LevelButton", {
    init: function(p) {
      this._super(p, {
        type: Q.SPRITE_UI | Q.SPRITE_DEFAULT,
        sheet: "ui_level_button",
        fontColor: "#595f5f",
        font: "400 70px Jolly Lodger"
      });
      if (this.p.level > 0) {
        this.p.label = "" + this.p.level;
      }
      this.p.sheetW = 172;
      this.p.sheetH = 130;
      this.p.cx = this.p.sheetW / 2;
      this.p.cy = this.p.sheetH / 2;
      if (this.p.enabled === false) {
        this.p.sheet = "ui_level_button_locked";
        this.p.label = false;
      }
      return this.on('click', () => {
        if (this.p.enabled) {
          if (this.p.level === 0) {
            return Game.stageTutorial();
          } else if (this.p.level === 1) {
            if (Game.settings.useKeyboardInstead.get()) {
              return Game.stageScreen("controls_keyboard");
            } else {
              return Game.stageScreen("controls");
            }
          } else {
            return Game.stageLevel(this.p.level);
          }
        } else {
          return Game.trackEvent("Level Button", "clicked", "locked");
        }
      });
    }
  });

  Q = Game.Q;

  Q.UI.LevelScoreImg = Q.Sprite.extend("Q.UI.LevelScoreImg", {
    init: function(p) {
      this._super(p, {
        x: 0,
        y: 0,
        sheet: "ui_level_score"
      });
      if (this.p.empty) {
        return this.p.sheet = "ui_level_score_empty";
      }
    }
  });

  Q = Game.Q;

  Q.UI.LevelScoreImgSmall = Q.Sprite.extend("Q.UI.LevelScoreImgSmall", {
    init: function(p) {
      return this._super(p, {
        x: 0,
        y: 0,
        sheet: "ui_level_score_small"
      });
    }
  });

  Q = Game.Q;

  Q.UI.MenuButton = Q.UI.Button.extend("UI.MenuButton", {
    init: function(p) {
      this._super(p, {
        x: Q.width - 30,
        y: 170,
        z: 100,
        type: Q.SPRITE_UI | Q.SPRITE_DEFAULT,
        keyActionName: "escape", // button that will trigger click event
        isSmall: true
      });
      if (this.p.isSmall) {
        this.p.sheet = "hud_back_button_small";
      } else {
        this.p.sheet = "hud_back_button";
      }
      return this.size(true); // force resize 
    }
  });

  Q = Game.Q;

  Q.UI.MoreLevelsButton = Q.UI.Button.extend("UI.MoreLevelsButton", {
    init: function(p) {
      this._super(p, {
        type: Q.SPRITE_UI | Q.SPRITE_DEFAULT,
        sheet: "ui_level_button",
        fontColor: "#595f5f",
        font: "400 32px Jolly Lodger",
        page: 0,
        fontColor: "#404444",
        align: 'center'
      });
      this.p.sheetW = 172;
      this.p.sheetH = 130;
      this.p.cx = this.p.sheetW / 2;
      this.p.cy = this.p.sheetH / 2;
      return this.on('click', () => {
        return Game.stageMoreLevels(this.p.page);
      });
    }
  });

  Q = Game.Q;

  Q.UI.PauseButton = Q.UI.Button.extend("UI.PauseButton", {
    init: function(p) {
      var pauseStage;
      this._super(p, {
        x: Q.width - 30,
        y: 110,
        z: 100,
        type: Q.SPRITE_UI | Q.SPRITE_DEFAULT,
        keyActionName: "pause", // button that will trigger click event
        isSmall: true,
        unpause: false
      });
      pauseStage = 10;
      if (this.p.isSmall) {
        this.p.sheet = "hud_pause_button_small";
      } else {
        this.p.sheet = "hud_pause_button";
      }
      this.size(true); // force resize 
      
      // Each button will be a "pause button" or an "unpause button"
      // not a toggle
      return this.on('click', () => {
        var j, l, len, len1, ref, ref1, stage;
        if (this.p.unpause) {
          Game.trackEvent("Pause Button", "clicked", "off");
          if (!Game.isMuted) {
            Q.AudioManager.playAll();
          }
          ref = Q.stages;
          for (j = 0, len = ref.length; j < len; j++) {
            stage = ref[j];
            if (stage) {
              stage.unpause();
            }
          }
          return Q.clearStage(pauseStage);
        } else {
          Game.trackEvent("Pause Button", "clicked", "on");
          Q.AudioManager.stopAll();
          ref1 = Q.stages;
          for (l = 0, len1 = ref1.length; l < len1; l++) {
            stage = ref1[l];
            if (stage) {
              stage.pause();
            }
          }
          return Q.stageScene("paused", pauseStage);
        }
      });
    }
  });

  Q = Game.Q;

  Q.UI.MenuButton = Q.UI.Button.extend("UI.MenuButton", {
    init: function(p) {
      this._super(p, {
        x: Q.width - 30,
        y: 170,
        z: 100,
        type: Q.SPRITE_UI | Q.SPRITE_DEFAULT,
        keyActionName: "escape", // button that will trigger click event
        isSmall: true
      });
      if (this.p.isSmall) {
        this.p.sheet = "hud_back_button_small";
      } else {
        this.p.sheet = "hud_back_button";
      }
      return this.size(true); // force resize 
    }
  });

  Q = Game.Q;

  Q.UI.SettingsButton = Q.UI.Button.extend("UI.SettingsButton", {
    init: function(p) {
      this._super(p, {
        type: Q.SPRITE_UI | Q.SPRITE_DEFAULT,
        sheet: "ui_level_button",
        fontColor: "#595f5f",
        font: "400 32px Jolly Lodger"
      });
      // label: "Settings"
      this.p.sheetW = 172;
      this.p.sheetH = 130;
      this.p.cx = this.p.sheetW / 2;
      this.p.cy = this.p.sheetH / 2;
      return this.on('click', () => {
        return Game.stageScreen("settings_menu");
      });
    }
  });

  //      Game.stageScreen("settingsPlaceholder")
  Q = Game.Q;

  Q.UI.ToggleButton = Q.UI.Button.extend("UI.ToggleButton", {
    init: function(p) {
      this._super(p, {
        x: 0,
        y: 0,
        type: Q.SPRITE_UI | Q.SPRITE_DEFAULT,
        pressed: false,
        sheet: "button_not_pressed",
        do_toggle: false
      });
      this.size(true); // force resize     
      if (this.p.do_toggle) {
        return this.on('click', () => {
          return this.pressed = !this.pressed;
        });
      }
    },
    draw: function(ctx) {
      var h, sheet, w;
      this._super(ctx);
      if (this.p.btn_sheet) {
        sheet = Q.sheet(this.p.btn_sheet);
        w = sheet.tileW;
        h = sheet.tileH;
        sheet.draw(ctx, -this.p.cx + (this.p.w - w) / 2, -this.p.cy + (this.p.h - h) / 2, this.p.frame);
      }
      if (this.pressed) {
        return Q.sheet("button_pressed").draw(ctx, -this.p.cx, -this.p.cy, this.p.frame);
      } else {
        // we redraw this on top of button icons as a form of greying out
        return Q.sheet("button_not_pressed").draw(ctx, -this.p.cx, -this.p.cy, this.p.frame);
      }
    }
  });

  Q = Game.Q;

  Q.UI.WarningIcon = Q.Sprite.extend("UI.WarningIcon", {
    init: function(p) {
      return this._super(p, {
        x: 0,
        y: 0,
        sheet: "warning"
      });
    }
  });

}).call(this);
